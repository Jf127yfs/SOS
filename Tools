/**
 * ============================================================================
 * TOOLS - TESTING AND UTILITY FUNCTIONS
 * ============================================================================
 * Helper functions for testing, debugging, and system maintenance
 *
 * CONTENTS:
 * 1. Testing Functions - Backend connectivity and data validation
 * 2. Analysis Functions - Check-in guest analysis and data completeness
 * 3. Documentation Functions - Master_Desc and Response Dictionary generation
 *
 * DEPENDENCIES:
 * - Uses CONFIG from Code.gs for sheet names and column mappings
 * - Requires getFRCSheet() and getCheckedInGuests() from Code.gs
 *
 * Last Updated: 2025-10-23
 * ============================================================================
 */

// ============================================================================
// SECTION 1: TESTING FUNCTIONS
// ============================================================================

/**
 * Test backend connectivity from frontend
 * Used by HTML pages to verify google.script.run is working
 */
function testBackend() {
  showMessage('Testing backend...', 'info');
  google.script.run
    .withSuccessHandler(function(result) {
      showMessage('✅ ' + result.message, 'success');
      console.log('Backend response:', result);
    })
    .withFailureHandler(function(error) {
      showMessage('❌ Backend error: ' + error.message, 'error');
      console.error('Connection failed:', error);
    })
    .testConnection();
}

/**
 * Test basic spreadsheet access and permissions
 * Verifies ability to read FRC sheet and count rows
 *
 * @returns {Object} Success status and message
 */
function testBasicAccess() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    Logger.log('✅ Can access spreadsheet: ' + ss.getName());

    // Use CONFIG.SHEETS.FRC instead of hardcoded 'FRC'
    const sheet = ss.getSheetByName(CONFIG.SHEETS.FRC);
    if (!sheet) {
      Logger.log('❌ FRC sheet not found!');
      Logger.log('Available sheets: ' + ss.getSheets().map(s => s.getName()).join(', '));
      return {success: false, message: 'FRC sheet not found'};
    }

    Logger.log('✅ Can access FRC sheet');
    Logger.log('✅ Row count: ' + sheet.getLastRow());

    return {success: true, message: 'All permissions OK'};

  } catch (error) {
    Logger.log('❌ ERROR: ' + error.toString());
    return {success: false, message: error.toString()};
  }
}

/**
 * Quick diagnostic test - lists all sheets and FRC headers
 * Useful for debugging sheet structure issues
 */
function quickTest() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  Logger.log('Spreadsheet: ' + ss.getName());

  const sheets = ss.getSheets().map(s => s.getName());
  Logger.log('All sheets: ' + sheets.join(', '));

  // Try to get FRC using CONFIG
  let frc = ss.getSheetByName(CONFIG.SHEETS.FRC);
  if (!frc) {
    // Fallback to alternative name
    frc = ss.getSheetByName('Form Responses (Clean)');
  }

  if (frc) {
    Logger.log('Found sheet: ' + frc.getName());
    const headers = frc.getRange(1, 1, 1, 30).getValues()[0];
    Logger.log('Headers: ' + JSON.stringify(headers));
  } else {
    Logger.log('❌ NO SHEET FOUND!');
  }
}
/**
 * Test check-in functionality with sample data
 * Replace the sample values with real data from your FRC sheet
 *
 * @returns {Object} Check-in result object
 */
function testWithRealData() {
  Logger.log('=== TESTING CHECK-IN WITH REAL DATA ===');

  // REPLACE THESE VALUES with actual guest data from FRC sheet:
  const result = checkInGuest('64110', 'man', '10/07');

  Logger.log('Result: ' + JSON.stringify(result, null, 2));

  return result;
}

// ============================================================================
// SECTION 2: ANALYSIS FUNCTIONS
// ============================================================================

/**
 * Analyze checked-in guests and their data completeness
 *
 * FUNCTION PURPOSE:
 * - Counts total checked-in guests
 * - Shows sample guest data structure
 * - Reports data completeness (photos, interests, music)
 *
 * DATA SOURCE: FRC sheet, Column AB (Checked-In = "Y")
 *
 * @returns {Object} Analysis results with total count and sample guest
 */
function analyzeCheckedInGuests() {
  Logger.log('=== ANALYZING CHECKED-IN GUESTS ===\n');

  const guests = getCheckedInGuests();

  Logger.log(`Total checked-in guests: ${guests.length}`);

  if (guests.length > 0) {
    Logger.log('\n=== SAMPLE GUEST DATA ===');
    const sample = guests[0];
    Logger.log(JSON.stringify(sample, null, 2));

    Logger.log('\n=== DATA COMPLETENESS ===');
    const withPhotos = guests.filter(g => g.photoUrl).length;
    const withInterests = guests.filter(g => g.interest1 || g.interest2 || g.interest3).length;
    const withMusic = guests.filter(g => g.music).length;

    Logger.log(`- Guests with photos: ${withPhotos}/${guests.length}`);
    Logger.log(`- Guests with interests: ${withInterests}/${guests.length}`);
    Logger.log(`- Guests with music prefs: ${withMusic}/${guests.length}`);
  }

  return {
    total: guests.length,
    sampleGuest: guests.length > 0 ? guests[0] : null
  };
}

// ============================================================================
// SECTION 3: DOCUMENTATION FUNCTIONS
// ============================================================================

/**
 * Generate Master_Desc sheet - comprehensive documentation of all sheets
 *
 * FUNCTION PURPOSE:
 * Documents all sheets in the spreadsheet with:
 * - Column names and numbers
 * - Data types
 * - Sample values
 * - Row counts
 * - Special notes
 *
 * OUTPUT SHEET: CONFIG.SHEETS.MASTER_DESC (Master_Desc)
 *
 * This function analyzes every sheet and column to create a data dictionary
 * that serves as the single source of truth for the spreadsheet structure.
 */
function generateMasterDesc() {
  const ss = SpreadsheetApp.getActive();
  const allSheets = ss.getSheets();

  // Prepare output data
  const output = [
    ['Sheet Name', 'Column #', 'Column Name', 'Data Type', 'Sample Values', 'Row Count', 'Notes']
  ];

  allSheets.forEach(sheet => {
    const sheetName = sheet.getName();

    // Skip Master_Desc itself (use CONFIG reference)
    if (sheetName === CONFIG.SHEETS.MASTER_DESC) return;
    
    const data = sheet.getDataRange().getValues();
    const rowCount = data.length;
    
    if (rowCount === 0) {
      output.push([sheetName, '', '(empty sheet)', '', '', 0, 'No data']);
      return;
    }
    
    const headers = data[0];
    
    // Document each column
    headers.forEach((header, colIdx) => {
      const colNum = colIdx + 1;
      const colName = String(header || `(Column ${colNum})`).trim();
      
      // Analyze column data type and get samples
      const analysis = analyzeColumn_(data, colIdx, sheetName);
      
      // Notes about special columns
      let notes = '';

      // Use CONFIG reference for data dictionary sheet
      if (sheetName === CONFIG.SHEETS.DATA_DICT) {
          if (colName === 'Sheet') notes = 'Source Sheet Name';
          else if (colName === 'Column Header') notes = 'Original Column Name';
          else if (colName === 'Column Number') notes = 'Original Column Letter';
          else if (colName === 'Response Value') notes = 'Unique Response String';
          else if (colName === 'Numerical Code / Status') notes = 'Assigned numerical code (or status)';
          else if (colName === 'Number of Responses') notes = 'Frequency count for the response';
          else if (colName === 'Notes') notes = 'Coding notes/Scale details';
      } else {
          // Notes for Form Responses 1 and any future data sheets
          if (colName.startsWith('code_')) notes = 'Categorical code';
          else if (colName.startsWith('oh_')) notes = 'One-hot encoded';
          else if (colName.startsWith('has_')) notes = 'Presence flag';
          else if (colName.toLowerCase().includes('timestamp')) notes = 'Timestamp';
          else if (colName === 'UID') notes = 'Unique identifier';
      }
      
      output.push([
        sheetName,
        colNum,
        colName,
        analysis.type,
        analysis.samples,
        rowCount - 1, // Data rows (excluding header)
        notes
      ]);
    });
    
    // Add a blank row between sheets for readability
    output.push(['', '', '', '', '', '', '']);
  });
  
  // Write to Master_Desc sheet
  writeMasterDesc_(output);
  
  // Format the sheet
  formatMasterDesc_();
  
  SpreadsheetApp.getUi().alert(
    `✅ Master_Desc generated!\n\n` +
    `Documented ${allSheets.length - 1} sheets with ${output.length - 1} total columns.`
  );
}

/**
 * Analyze a column to determine data type and get sample values
 *
 * @param {Array} data - Sheet data array
 * @param {number} colIdx - Column index (0-based)
 * @param {string} sheetName - Name of the sheet being analyzed
 * @returns {Object} Object with type and samples
 * @private
 */
function analyzeColumn_(data, colIdx, sheetName) {
  if (data.length < 2) {
    return { type: 'Empty', samples: '' };
  }
  
  // Get up to 3 unique non-empty sample values (excluding header)
  const samples = [];
  const seen = new Set();
  
  // Start from row 1 to skip header
  for (let i = 1; i < data.length && samples.length < 3; i++) {
    let val = data[i][colIdx];

    // Skip rows marked as condensed text status (use CONFIG reference)
    if (sheetName === CONFIG.SHEETS.DATA_DICT && colIdx === 3 && val === '--- Free-Text/Identifier ---') {
        continue;
    }
    
    if (val === null || val === undefined || val === '') continue;
    
    const valStr = String(val).trim();
    if (valStr && !seen.has(valStr)) {
      seen.add(valStr);

      // Use short form for number of responses in the Master_Desc sample (use CONFIG reference)
      if (sheetName === CONFIG.SHEETS.DATA_DICT && colIdx === 5) {
          samples.push(`${valStr} responses`);
      } else {
          samples.push(valStr);
      }
    }
  }
  
  // Determine data type
  let type = 'Unknown';
  if (samples.length > 0) {
    const firstVal = data[1][colIdx];
    
    if (firstVal instanceof Date) {
      type = 'Date';
    } else if (typeof firstVal === 'number') {
      // Check if it's all 0s and 1s (binary flag)
      const allBinary = data.slice(1).every(row => {
        const v = row[colIdx];
        return v === 0 || v === 1 || v === '' || v === null;
      });
      type = allBinary ? 'Binary (0/1)' : 'Number';
    } else if (typeof firstVal === 'string') {
      // Check if it looks like codes (all numeric strings 1-N)
      const allCodes = data.slice(1, Math.min(20, data.length)).every(row => {
        const v = row[colIdx];
        if (v === '' || v === null) return true;
        const num = Number(v);
        return isFinite(num) && num >= 1 && num <= 99999;
      });
      type = allCodes ? 'Code (1-N)' : 'Text';
    }
  }
  
  // Override for specific dictionary columns (use CONFIG reference)
  if (sheetName === CONFIG.SHEETS.DATA_DICT) {
      if (colIdx === 2) type = 'Column Letter'; // Column Number (E)
      if (colIdx === 4) type = 'Code/Text Status'; // Numerical Code / Status
      if (colIdx === 5) type = 'Number'; // Number of Responses
  }
  
  return {
    type: type,
    samples: samples.join('; ')
  };
}

/**
 * Write output to Master_Desc sheet
 *
 * @param {Array} data - 2D array of output data
 * @private
 */
function writeMasterDesc_(data) {
  const ss = SpreadsheetApp.getActive();
  let sheet = ss.getSheetByName(CONFIG.SHEETS.MASTER_DESC);

  if (!sheet) {
    sheet = ss.insertSheet(CONFIG.SHEETS.MASTER_DESC, 0); // Insert as first sheet
  } else {
    sheet.clear();
  }
  
  if (data.length === 0) return;
  
  // Use data[0].length to account for the actual number of columns (7)
  sheet.getRange(1, 1, data.length, data[0].length).setValues(data);
}

/**
 * Format Master_Desc sheet for better readability
 * Adds colors, borders, column widths, and freezes header row
 *
 * @private
 */
function formatMasterDesc_() {
  const ss = SpreadsheetApp.getActive();
  const sheet = ss.getSheetByName(CONFIG.SHEETS.MASTER_DESC);
  if (!sheet) return;
  
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow < 1 || lastCol < 1) return;
  
  // Format header row
  const headerRange = sheet.getRange(1, 1, 1, lastCol);
  headerRange
    .setBackground('#434343')
    .setFontColor('#ffffff')
    .setFontWeight('bold')
    .setFontSize(11);
  
  // Freeze header row
  sheet.setFrozenRows(1);
  
  // Auto-resize all columns
  for (let i = 1; i <= lastCol; i++) {
    sheet.autoResizeColumn(i);
  }
  
  // Set column widths for specific columns
  sheet.setColumnWidth(1, 180); // Sheet Name
  sheet.setColumnWidth(2, 80);  // Column #
  sheet.setColumnWidth(3, 200); // Column Name
  sheet.setColumnWidth(4, 120); // Data Type
  sheet.setColumnWidth(5, 250); // Sample Values
  sheet.setColumnWidth(6, 100); // Row Count
  sheet.setColumnWidth(7, 150); // Notes
  
  // Add alternating row colors for each sheet
  if (lastRow > 1) {
    let currentSheet = '';
    let useGray = false;
    
    for (let row = 2; row <= lastRow; row++) {
      const sheetName = sheet.getRange(row, 1).getValue();
      
      if (sheetName && sheetName !== currentSheet) {
        currentSheet = sheetName;
        useGray = !useGray;
      }
      
      if (sheetName) { // Only color non-empty rows
        const rowRange = sheet.getRange(row, 1, 1, lastCol);
        if (useGray) {
          rowRange.setBackground('#f3f3f3');
        }
      }
    }
  }
  
  // Add borders
  if (lastRow > 1) {
    sheet.getRange(2, 1, lastRow - 1, lastCol)
      .setBorder(null, null, true, null, null, null, '#cccccc', SpreadsheetApp.BorderStyle.SOLID_THIN);
  }
  
  // Center align column numbers and row counts
  if (lastRow > 1) {
    sheet.getRange(2, 2, lastRow - 1, 1).setHorizontalAlignment('center'); // Column #
    sheet.getRange(2, 6, lastRow - 1, 1).setHorizontalAlignment('center'); // Row Count
  }
}

/**
 * ============================================================================
 * CREATE RESPONSE DICTIONARY
 * ============================================================================
 *
 * Creates a comprehensive dictionary (pan dict) of unique text responses
 * from the "Form Responses 1" sheet and assigns a numerical code to each.
 *
 * PURPOSE:
 * - Analyzes all text responses in the source sheet
 * - Assigns numerical codes based on frequency
 * - Creates a lookup table for data encoding
 *
 * OUTPUT SHEET: CONFIG.SHEETS.DATA_DICT (Response_Pan_Dictionary)
 *
 * The output sheet is structured by source column order, with responses
 * sorted by frequency (most common first), including a "Number of Responses" column.
 *
 * NOTE: This function references "Form Responses 1" which is the original form
 * data before it's cleaned into FRC. If you need to run this on FRC instead,
 * update the SOURCE_SHEET constant below.
 */
function createResponseDictionary() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  // SOURCE SHEET - Update this if your source data has a different name
  const SOURCE_SHEET = "Form Responses 1"; // Original form responses
  const sheet = ss.getSheetByName(SOURCE_SHEET);

  if (!sheet) {
    Logger.log(`Error: Sheet named "${SOURCE_SHEET}" not found. Please ensure the sheet name is correct.`);
    SpreadsheetApp.getUi().alert(`Error: Sheet named "${SOURCE_SHEET}" not found.`);
    return;
  }

  // Get actual sheet name for use in dictionary keys and output
  const sheetName = sheet.getName();

  // --- Configuration ---
  const EXCLUDE_COLUMNS = ["Screen Name", "UID", "Timestamp", "Checked-In", "Check-in Time", "PHOTO_URL_COL"];
  const CONDENSED_TEXT_COLUMNS = ["Birthday (MM/DD)", "Current 5 Digit Zip Code", "Current Favorite Artist", "Name one song you want to hear at the party."];
  const INTEREST_HEADER = "Your General Interests (Choose 3)";
  const SCALE_COLUMNS = ["If yes, how well do you know them?", "Which best describes your general social stance?"];

  const SCALED_COLUMNS_NOTES = {
    "If yes, how well do you know them?": {
      "1": "Acquaintance", "2": "Know casually / See occasionally", "3": "Moderately known / Social connection",
      "4": "Well known / Close friend", "5": "Extremely well / Very close"
    },
    "Which best describes your general social stance?": {
      "1": "Introverted", "2": "Slightly introverted", "3": "Balanced / Ambivert",
      "4": "Slightly extroverted", "5": "Extroverted"
    }
  };
  // --- End Configuration ---
  
  
  const range = sheet.getDataRange();
  const values = range.getValues(); 

  if (values.length < 2) {
    SpreadsheetApp.getUi().alert("Error: Sheet is empty or only contains headers.");
    return;
  }

  const headers = values[0];
  const data = values.slice(1); 
  
  // Helper to convert column index (0-based) to letter (e.g., 0->A, 25->Z, 26->AA)
  const colIndexToLetter = (index) => {
    let letter = '';
    while (index >= 0) {
      letter = String.fromCharCode(65 + (index % 26)) + letter;
      index = Math.floor(index / 26) - 1;
    }
    return letter;
  };
  
  const fullPanDict = {}; 
  const outputData = [
    ["Sheet", "Column Header", "Column Number", "Response Value", "Numerical Code / Status", "Number of Responses", "Notes"]
  ];
  
  
  // 1. Loop through columns in order
  headers.forEach((header, colIndex) => {
    
    const columnIndex = colIndex + 1; // 1-based index
    const columnLetter = colIndexToLetter(colIndex);
    
    // Key format: "Sheet (Column Header) Column Number"
    const dictKey = `${sheetName} (${header}) ${columnIndex}`;

    // Metadata for the current column
    const meta = { sheet: sheetName, row: 1, columnIndex: columnIndex, columnHeader: header };

    // Check for explicit exclusions
    if (EXCLUDE_COLUMNS.includes(header)) {
      return; 
    }

    // Handle CONDENSED_TEXT_COLUMNS
    if (CONDENSED_TEXT_COLUMNS.includes(header)) {
      outputData.push([
        sheetName, header, columnLetter, 
        "--- Free-Text/Identifier ---", "Text Value", "N/A", 
        "Not coded; unique values can be referenced from the source sheet."
      ]);
      return;
    }

    // --- Data Processing and Counting ---
    
    const responseCounts = {};
    const isInterestHeader = header === INTEREST_HEADER;
    
    // 1. Calculate the frequency of each unique response
    data.forEach(row => {
      let cellValue = String(row[colIndex]).trim();
      
      if (!cellValue) return;
      
      let responsesToCount = [cellValue];
      
      if (isInterestHeader) {
        // Split comma-separated values for multi-response
        responsesToCount = cellValue.split(',').map(item => item.trim()).filter(item => item);
      }
      
      responsesToCount.forEach(response => {
        responseCounts[response] = (responseCounts[response] || 0) + 1;
      });
    });

    const uniqueResponses = Object.keys(responseCounts);
    
    if (uniqueResponses.length > 0) {
      let sortedResponses = uniqueResponses.map(response => ({
        response: response,
        count: responseCounts[response]
      }));
      
      const isScaleColumn = SCALE_COLUMNS.includes(header);

      // 2. Sort the responses: By COUNT (descending) first, then by the original value (alphabetically/numerically)
      sortedResponses.sort((a, b) => {
        if (isScaleColumn) {
          const numA = parseInt(a.response, 10);
          const numB = parseInt(b.response, 10);
          return numA - numB;
        }
        
        if (b.count !== a.count) {
          return b.count - a.count; 
        }
        
        return a.response.localeCompare(b.response);
      });
      
      // 3. Assign Numerical Codes based on the final sorted order
      const columnDict = {};
      let sequentialCode = 1;

      sortedResponses.forEach(item => {
        const response = item.response;
        const count = item.count;
        let numCode;
        let notes = "";

        if (isScaleColumn) {
          // Code IS the response value (1, 2, 3, 4, 5)
          numCode = parseInt(response, 10);
          notes = SCALED_COLUMNS_NOTES[header][response] || "";
        } else {
          // Code is based on frequency rank (1, 2, 3...)
          numCode = sequentialCode;
          sequentialCode++;
        }
        
        // Finalize notes
        if (header === "Recent purchase you’re most happy about") {
            notes = "Response was numerically coded.";
        } else if (isInterestHeader) {
            notes = "Coded as part of a multi-response set.";
        }
        
        // Store in the dictionary object
        columnDict[response] = numCode;
        
        // Add to the output sheet array
        outputData.push([
          sheetName, header, columnLetter, 
          response, numCode, count, notes
        ]);
      });

      // Add the column's mapping and metadata to the main dictionary object
      fullPanDict[dictKey] = { meta: meta, mapping: columnDict };
    }
  });

  // --- Output Section ---

  Logger.log("--- Full Pan Dictionary (JSON format) ---");
  Logger.log(JSON.stringify(fullPanDict, null, 2));

  // Create or update the persistent lookup sheet (use CONFIG reference)
  let dictSheet = ss.getSheetByName(CONFIG.SHEETS.DATA_DICT);

  if (dictSheet) {
    dictSheet.clearContents();
  } else {
    dictSheet = ss.insertSheet(CONFIG.SHEETS.DATA_DICT);
  }

  if (outputData.length > 1) {
    dictSheet.getRange(1, 1, outputData.length, 7).setValues(outputData);

    // Formatting
    dictSheet.setFrozenRows(1);
    dictSheet.getRange(1, 1, 1, 7).setFontWeight("bold").setBackground("#cfe2f3");
    dictSheet.autoResizeColumns(1, 7);

    SpreadsheetApp.getUi().alert(
      `Success! The response dictionary has been generated.\n\n` +
      `Check the new sheet: "${CONFIG.SHEETS.DATA_DICT}"`
    );
  } else {
     SpreadsheetApp.getUi().alert("No responses were found to process.");
  }
}

// ============================================================================
// SECTION 4: MATCHMAKING ANALYTICS
// ============================================================================

// analyzeMatchingPool() function removed - not needed per user request

/**
 * Generate comprehensive Gen_Report with Cramér's V correlation analysis
 *
 * FUNCTION PURPOSE:
 * Creates statistical analysis report to identify patterns and correlations
 * in guest data. Used to inform matchmaking algorithm design.
 *
 * DATA SOURCE:
 * - FRC sheet (CONFIG.SHEETS.FRC)
 * - ALL guests with timestamps (not just checked-in)
 * - Guest count = rows with value in Column 1 (Timestamp)
 *
 * ATTRIBUTES ANALYZED (14 total, excluding ethnicity):
 * Demographics: Age, Gender, Orientation, Education, Zodiac
 * Professional: Industry, Role
 * Personality: Social Stance, At Worst
 * Interests: Interest_1, Interest_2, Interest_3, Music, Recent Purchase
 * Social: Know Hosts
 *
 * OUTPUT SECTIONS:
 * 1. Overview (guest count, attributes analyzed)
 * 2. Cramér's V by Category (grouped analysis)
 * 3. Full Cramér's V Matrix (all pairs)
 * 4. Top 10 Correlations (strongest relationships)
 * 5. Surprising Correlations (unexpected findings)
 * 6. Frequency Distributions (value counts)
 *
 * @returns {boolean} Success status
 */
function generateGenReport() {
  Logger.log('=== GENERATING GEN_REPORT ===');

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const frcSheet = ss.getSheetByName(CONFIG.SHEETS.FRC);

  if (!frcSheet) {
    SpreadsheetApp.getUi().alert('Error: FRC sheet not found');
    return false;
  }

  // Get all data
  const data = frcSheet.getDataRange().getValues();
  const headers = data[0];

  // Count guests with timestamps (Column 1 has value)
  const guests = data.slice(1).filter(row => row[CONFIG.COL.TIMESTAMP]);
  const totalGuests = guests.length;

  Logger.log(`Total guests with timestamps: ${totalGuests}`);

  if (totalGuests === 0) {
    SpreadsheetApp.getUi().alert('Error: No guests found with timestamps');
    return false;
  }

  // Define attribute groups for analysis (EXCLUDING ETHNICITY)
  const attributes = {
    // Demographics
    'Age Range': { col: CONFIG.COL.AGE, category: 'Demographics' },
    'Gender': { col: CONFIG.COL.GENDER, category: 'Demographics' },
    'Orientation': { col: CONFIG.COL.ORIENTATION, category: 'Demographics' },
    'Education': { col: CONFIG.COL.EDU, category: 'Demographics' },
    'Zodiac': { col: CONFIG.COL.ZODIAC, category: 'Demographics' },

    // Professional
    'Industry': { col: CONFIG.COL.INDUSTRY, category: 'Professional' },
    'Role': { col: CONFIG.COL.ROLE, category: 'Professional' },

    // Personality
    'Social Stance': { col: CONFIG.COL.SOCIAL_STANCE, category: 'Personality' },
    'At Worst': { col: CONFIG.COL.AT_WORST, category: 'Personality' },

    // Interests (HIGH priority for matching)
    'Interest 1': { col: CONFIG.COL.INTEREST_1, category: 'Interests' },
    'Interest 2': { col: CONFIG.COL.INTEREST_2, category: 'Interests' },
    'Interest 3': { col: CONFIG.COL.INTEREST_3, category: 'Interests' },
    'Music': { col: CONFIG.COL.MUSIC, category: 'Interests' },
    'Recent Purchase': { col: CONFIG.COL.RECENT_PURCHASE, category: 'Interests' },

    // Social
    'Know Hosts': { col: CONFIG.COL.KNOW_HOSTS, category: 'Social' }
  };

  Logger.log(`Analyzing ${Object.keys(attributes).length} attributes`);

  // Calculate Cramér's V for all pairs
  const cramersMatrix = {};
  const allPairs = [];
  const attrNames = Object.keys(attributes);

  Logger.log('Calculating Cramér\'s V for all pairs...');

  for (let i = 0; i < attrNames.length; i++) {
    const attr1 = attrNames[i];
    // Don't overwrite if already exists (values set from previous iterations)
    cramersMatrix[attr1] = cramersMatrix[attr1] || {};

    for (let j = 0; j < attrNames.length; j++) {
      const attr2 = attrNames[j];

      if (i === j) {
        cramersMatrix[attr1][attr2] = 1.0; // Perfect correlation with self
      } else if (i < j) {
        // Calculate Cramér's V
        const v = calculateCramersV(
          guests,
          attributes[attr1].col,
          attributes[attr2].col
        );
        cramersMatrix[attr1][attr2] = v;
        cramersMatrix[attr2] = cramersMatrix[attr2] || {};
        cramersMatrix[attr2][attr1] = v; // Symmetric

        allPairs.push({
          attr1: attr1,
          attr2: attr2,
          value: v,
          cat1: attributes[attr1].category,
          cat2: attributes[attr2].category
        });
      }
    }
  }

  // Sort pairs by correlation strength
  allPairs.sort((a, b) => b.value - a.value);
  const top10 = allPairs.slice(0, 10);

  // Find surprising correlations (moderate strength, unexpected categories)
  const surprising = allPairs.filter(p =>
    p.value > 0.2 && p.value < 0.5 && p.cat1 !== p.cat2
  ).slice(0, 10);

  Logger.log('Creating Gen_Report sheet...');

  // Create or clear Gen_Report sheet
  let reportSheet = ss.getSheetByName('Gen_Report');
  if (reportSheet) {
    reportSheet.clear();
  } else {
    reportSheet = ss.insertSheet('Gen_Report');
  }

  // Build report output
  const output = [];
  let row = 0;

  // SECTION 1: OVERVIEW
  output.push(['GEN_REPORT - Statistical Analysis for Matchmaking Algorithm']);
  output.push(['Generated:', new Date().toLocaleString()]);
  output.push(['']);
  output.push(['OVERVIEW']);
  output.push(['Total Guests (with timestamps):', totalGuests]);
  output.push(['Attributes Analyzed:', Object.keys(attributes).length]);
  output.push(['Ethnicity:', 'EXCLUDED (privacy)']);
  output.push(['']);

  // SECTION 2: TOP 10 CORRELATIONS
  output.push(['TOP 10 STRONGEST CORRELATIONS (Cramér\'s V)']);
  output.push(['Rank', 'Attribute 1', 'Attribute 2', 'Correlation', 'Category 1', 'Category 2']);
  top10.forEach((p, i) => {
    output.push([
      i + 1,
      p.attr1,
      p.attr2,
      p.value.toFixed(3),
      p.cat1,
      p.cat2
    ]);
  });
  output.push(['']);

  // SECTION 3: SURPRISING CORRELATIONS
  output.push(['SURPRISING CORRELATIONS (Cross-category, moderate strength)']);
  output.push(['Attribute 1', 'Attribute 2', 'Correlation', 'Category 1', 'Category 2']);
  surprising.forEach(p => {
    output.push([
      p.attr1,
      p.attr2,
      p.value.toFixed(3),
      p.cat1,
      p.cat2
    ]);
  });
  output.push(['']);

  // SECTION 4: CRAMÉR'S V MATRIX (Full heatmap)
  output.push(['FULL CRAMÉR\'S V MATRIX']);
  const matrixHeader = [''].concat(attrNames);
  output.push(matrixHeader);

  attrNames.forEach(attr1 => {
    const row = [attr1];
    attrNames.forEach(attr2 => {
      const value = cramersMatrix[attr1] && cramersMatrix[attr1][attr2] !== undefined
        ? cramersMatrix[attr1][attr2].toFixed(3)
        : '0.000';
      row.push(value);
    });
    output.push(row);
  });
  output.push(['']);

  // SECTION 5: FREQUENCY DISTRIBUTIONS
  output.push(['FREQUENCY DISTRIBUTIONS']);
  output.push(['']);

  Object.keys(attributes).forEach(attrName => {
    const col = attributes[attrName].col;
    const counts = {};

    guests.forEach(guest => {
      const value = String(guest[col] || 'N/A').trim();
      counts[value] = (counts[value] || 0) + 1;
    });

    output.push([attrName + ' (' + attributes[attrName].category + ')']);
    output.push(['Value', 'Count', 'Percentage']);

    Object.entries(counts)
      .sort((a, b) => b[1] - a[1])
      .forEach(([value, count]) => {
        output.push([
          value,
          count,
          ((count / totalGuests) * 100).toFixed(1) + '%'
        ]);
      });

    output.push(['']);
  });

  // Write to sheet
  if (output.length > 0) {
    reportSheet.getRange(1, 1, output.length, output[0].length).setValues(output);
  }

  // Format sheet
  reportSheet.getRange(1, 1, 1, output[0].length).setFontWeight('bold').setFontSize(14);
  reportSheet.setFrozenRows(1);
  reportSheet.autoResizeColumns(1, output[0].length);

  // Highlight section headers
  const sectionRows = [1, 9, 9 + top10.length + 2, 9 + top10.length + 2 + surprising.length + 2];
  sectionRows.forEach(r => {
    if (r <= output.length) {
      reportSheet.getRange(r, 1, 1, output[0].length)
        .setBackground('#4285f4')
        .setFontColor('#ffffff')
        .setFontWeight('bold');
    }
  });

  Logger.log('Gen_Report created successfully!');

  SpreadsheetApp.getUi().alert(
    'Gen_Report Generated',
    `Analysis complete!\n\n` +
    `Total Guests: ${totalGuests}\n` +
    `Attributes: ${Object.keys(attributes).length}\n` +
    `Top Correlation: ${top10[0].attr1} ↔ ${top10[0].attr2} (${top10[0].value.toFixed(3)})\n\n` +
    `Check the Gen_Report sheet for full analysis.`,
    SpreadsheetApp.getUi().ButtonSet.OK
  );

  return true;
}

/**
 * Calculate Cramér's V statistic between two categorical variables
 *
 * @param {Array} data - Guest data array
 * @param {number} col1 - First column index
 * @param {number} col2 - Second column index
 * @returns {number} Cramér's V value (0-1)
 * @private
 */
function calculateCramersV(data, col1, col2) {
  // Build contingency table
  const table = {};
  const row1Totals = {};
  const col2Totals = {};
  let n = 0;

  data.forEach(row => {
    const val1 = String(row[col1] || 'N/A').trim();
    const val2 = String(row[col2] || 'N/A').trim();

    if (!table[val1]) table[val1] = {};
    table[val1][val2] = (table[val1][val2] || 0) + 1;

    row1Totals[val1] = (row1Totals[val1] || 0) + 1;
    col2Totals[val2] = (col2Totals[val2] || 0) + 1;
    n++;
  });

  // Calculate chi-square
  let chiSquare = 0;
  Object.keys(table).forEach(val1 => {
    Object.keys(table[val1]).forEach(val2 => {
      const observed = table[val1][val2];
      const expected = (row1Totals[val1] * col2Totals[val2]) / n;
      chiSquare += Math.pow(observed - expected, 2) / expected;
    });
  });

  // Calculate Cramér's V
  const r = Object.keys(row1Totals).length;
  const c = Object.keys(col2Totals).length;
  const cramersV = Math.sqrt(chiSquare / (n * Math.min(r - 1, c - 1)));

  return cramersV;
}

/**
 * ============================================================================
 * END OF TOOLS
 * ============================================================================
 *
 * NOTES:
 * - All sheet references now use CONFIG.SHEETS from Code.gs
 * - Testing functions help verify system functionality
 * - Analysis functions provide data insights
 * - Documentation functions auto-generate data dictionaries
 * - Matchmaking analytics help design algorithm thresholds
 *
 * For questions about column mappings, see SheetLocations file or CONFIG in Code.gs
 * ============================================================================
 */
