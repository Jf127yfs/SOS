/**
 * ============================================================================
 * MM COMPATIBILITY MATCHING SYSTEM - mmCode
 * ============================================================================
 * 
 * STANDALONE MODULE for Match Maker (MM) page
 * Kept separate from Code.gs for easier troubleshooting
 * 
 * FUNCTIONS:
 * 1. getCompatibilityMatches() - Main matching logic for MM page
 * 2. syncPhotosFromDrive() - Photo URL optimization
 * 3. convertDriveUrlToDirectLink() - URL format converter
 * 
 * DEPENDENCIES:
 * - Guest_Similarity sheet (generated by ANALYTICSTest.buildGuestSimilarity())
 * - FRC sheet with checked-in guest data
 * 
 * CALLED BY: mm.html via google.script.run
 * ============================================================================
 */

/**
 * Get compatibility matches for MM page
 * 
 * Reads from Guest_Similarity matrix and filters to checked-in guests only.
 * Returns top 100 match pairs sorted by similarity with shared interests.
 * 
 * @return {Object} {matches: Array, totalGuests: Number}
 */
function getCompatibilityMatches() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    // Load Guest_Similarity sheet
    const simSheet = ss.getSheetByName('Guest_Similarity');
    if (!simSheet) {
      Logger.log('❌ Guest_Similarity sheet not found');
      return {
        matches: [],
        totalGuests: 0,
        error: 'Guest_Similarity sheet not found. Please run ANALYTICSTest.buildGuestSimilarity() first.'
      };
    }

    // Load FRC sheet for checked-in guest data
    const frcSheet = ss.getSheetByName('FRC');
    if (!frcSheet) {
      Logger.log('❌ FRC sheet not found');
      return {
        matches: [],
        totalGuests: 0,
        error: 'FRC sheet not found'
      };
    }

    // Get FRC data
    const frcData = frcSheet.getDataRange().getValues();

    // Build map of checked-in guests with their data
    const checkedInGuests = {};
    for (let i = 1; i < frcData.length; i++) {
      const row = frcData[i];
      const checkedIn = String(row[27] || '').trim().toUpperCase(); // Column AB (Checked-In)

      if (checkedIn === 'Y') {
        const screenName = String(row[24] || '').trim(); // Column Y (Screen Name)
        const uid = String(row[25] || '').trim(); // Column Z (UID)

        if (screenName && uid) {
          checkedInGuests[screenName] = {
            screenName: screenName,
            uid: uid,
            zodiac: String(row[2] || '---').trim(), // Column C
            music: String(row[18] || '---').trim(), // Column S
            photoUrl: convertDriveUrlToDirectLink(String(row[29] || '').trim()), // Column AD (PHOTO_URL)
            interests: [
              String(row[15] || '').trim(), // Column P (Interest_1)
              String(row[16] || '').trim(), // Column Q (Interest_2)
              String(row[17] || '').trim()  // Column R (Interest_3)
            ].filter(i => i !== '')
          };
        }
      }
    }

    const checkedInNames = Object.keys(checkedInGuests);
    Logger.log('✅ Found ' + checkedInNames.length + ' checked-in guests');

    if (checkedInNames.length === 0) {
      return {
        matches: [],
        totalGuests: 0,
        message: 'No checked-in guests found'
      };
    }

    // Get Guest_Similarity matrix
    const simData = simSheet.getDataRange().getValues();
    const simHeaders = simData[0]; // Row 1: headers (Screen Name (UID))

    // Build column index map for checked-in guests
    const guestColMap = {};
    for (let col = 1; col < simHeaders.length; col++) {
      const header = String(simHeaders[col]).trim();
      const screenName = header.split(' (')[0]; // Extract screen name from "Screen Name (UID)"

      if (checkedInGuests[screenName]) {
        guestColMap[screenName] = col;
      }
    }

    // Build row index map for checked-in guests
    const guestRowMap = {};
    for (let row = 1; row < simData.length; row++) {
      const rowHeader = String(simData[row][0]).trim();
      const screenName = rowHeader.split(' (')[0];

      if (checkedInGuests[screenName]) {
        guestRowMap[screenName] = row;
      }
    }

    // Extract all similarity pairs for checked-in guests
    const matches = [];
    const processedPairs = new Set();

    for (const name1 of checkedInNames) {
      const row = guestRowMap[name1];
      if (row === undefined) continue;

      for (const name2 of checkedInNames) {
        if (name1 === name2) continue;

        const col = guestColMap[name2];
        if (col === undefined) continue;

        // Create unique pair ID (alphabetical order to avoid duplicates)
        const pairId = [name1, name2].sort().join('|');
        if (processedPairs.has(pairId)) continue;
        processedPairs.add(pairId);

        // Get similarity score
        const similarity = parseFloat(simData[row][col]) || 0;

        // Calculate shared interests
        const interests1 = new Set(checkedInGuests[name1].interests);
        const interests2 = new Set(checkedInGuests[name2].interests);
        const sharedInterests = [...interests1].filter(i => interests2.has(i));

        matches.push({
          person1: checkedInGuests[name1],
          person2: checkedInGuests[name2],
          similarity: similarity, // Raw similarity (0.0 - 1.0)
          sharedInterests: sharedInterests
        });
      }
    }

    // Sort by similarity (highest first)
    matches.sort((a, b) => b.similarity - a.similarity);

    // Take top 100 matches for performance
    const topMatches = matches.slice(0, 100);

    Logger.log('✅ Generated ' + topMatches.length + ' matches from ' + checkedInNames.length + ' checked-in guests');

    return {
      matches: topMatches,
      totalGuests: checkedInNames.length
    };

  } catch (error) {
    Logger.log('❌ Error in getCompatibilityMatches: ' + error.toString());
    Logger.log('Stack: ' + error.stack);
    return {
      matches: [],
      totalGuests: 0,
      error: error.toString()
    };
  }
}

/**
 * Sync photos from Drive - convert sharing URLs to direct thumbnail links
 * 
 * Updates FRC sheet Photo URL column (AD) with optimized thumbnail links
 * for faster loading in the MM page.
 * 
 * @return {Object} {success: Boolean, updated: Number, message: String}
 */
function syncPhotosFromDrive() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const frcSheet = ss.getSheetByName('FRC');

    if (!frcSheet) {
      return { success: false, message: 'FRC sheet not found' };
    }

    const data = frcSheet.getDataRange().getValues();
    const photoUrlCol = 29; // Column AD (0-indexed = 29) - PHOTO_URL_COL

    let updatedCount = 0;

    for (let i = 1; i < data.length; i++) {
      const currentUrl = data[i][photoUrlCol];

      if (currentUrl && typeof currentUrl === 'string' && currentUrl.includes('drive.google.com')) {
        // Skip if already in thumbnail format
        if (currentUrl.includes('/thumbnail?id=')) {
          continue;
        }

        // Convert any other Drive URL format to thumbnail
        const thumbnailUrl = convertDriveUrlToDirectLink(currentUrl);

        if (thumbnailUrl !== currentUrl) {
          frcSheet.getRange(i + 1, photoUrlCol + 1).setValue(thumbnailUrl);
          updatedCount++;
          Logger.log('Row ' + (i + 1) + ': Updated photo URL');
        }
      }
    }

    Logger.log('✅ Photo sync complete: ' + updatedCount + ' URLs converted');

    return {
      success: true,
      updated: updatedCount,
      message: 'Successfully converted ' + updatedCount + ' photo URLs'
    };

  } catch (error) {
    Logger.log('❌ Error: ' + error.toString());
    return { success: false, message: error.toString() };
  }
}

/**
 * Convert Drive sharing URLs to direct thumbnail links
 * 
 * Extracts file ID from various Drive URL formats and converts to optimized
 * thumbnail link for use in <img> tags.
 * 
 * Supported formats:
 * - /file/d/FILEID/view
 * - ?id=FILEID
 * - /uc?export=view&id=FILEID
 * 
 * @param {String} driveUrl - Original Drive URL
 * @return {String} Thumbnail URL or original URL if conversion fails
 */
function convertDriveUrlToDirectLink(driveUrl) {
  if (!driveUrl || driveUrl === '') return '';

  try {
    let fileId = null;

    // Format 1: /file/d/FILEID/view or /file/d/FILEID
    let match = driveUrl.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
    if (match) {
      fileId = match[1];
    }

    // Format 2: ?id=FILEID or &id=FILEID
    if (!fileId) {
      match = driveUrl.match(/[?&]id=([a-zA-Z0-9_-]+)/);
      if (match) {
        fileId = match[1];
      }
    }

    // If we found a file ID, return thumbnail link
    if (fileId) {
      return 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w500';
    }

    // If already a thumbnail link, return as-is
    if (driveUrl.includes('drive.google.com/thumbnail')) {
      return driveUrl;
    }

    // If old format (/uc?export=view), convert to thumbnail
    if (driveUrl.includes('drive.google.com/uc?export=view')) {
      const match2 = driveUrl.match(/[?&]id=([a-zA-Z0-9_-]+)/);
      if (match2) {
        return 'https://drive.google.com/thumbnail?id=' + match2[1] + '&sz=w500';
      }
    }

    return driveUrl;

  } catch (error) {
    Logger.log('❌ Error converting Drive URL: ' + error.toString());
    return driveUrl;
  }
}
