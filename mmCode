/**
 * ============================================================================
 * MM COMPATIBILITY MATCHING SYSTEM - mmCode
 * ============================================================================
 * 
 * STANDALONE MODULE for Match Maker (MM) page
 * Kept separate from Code.gs for easier troubleshooting
 * 
 * FUNCTIONS:
 * 1. getCompatibilityMatches() - Main matching logic for MM page
 * 2. syncPhotosFromDrive() - Photo URL optimization
 * 3. convertDriveUrlToDirectLink() - URL format converter
 * 
 * DEPENDENCIES:
 * - Guest_Similarity sheet (generated by ANALYTICSTest.buildGuestSimilarity())
 * - FRC sheet with checked-in guest data
 * 
 * CALLED BY: mm.html via google.script.run
 * ============================================================================
 */

/**
 * Get compatibility matches for MM page
 *
 * Reads from Guest_Similarity matrix and filters to checked-in guests only.
 * Returns top 100 match pairs sorted by similarity with shared interests.
 *
 * @return {Object} {matches: Array, totalGuests: Number}
 */
function getCompatibilityMatches() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();

    // Load Guest_Similarity sheet
    const simSheet = ss.getSheetByName('Guest_Similarity');
    if (!simSheet) {
      Logger.log('‚ùå Guest_Similarity sheet not found');
      return {
        matches: [],
        totalGuests: 0,
        error: 'Guest_Similarity sheet not found. Please run ANALYTICSTest.buildGuestSimilarity() first.'
      };
    }

    // Load FRC sheet for checked-in guest data
    const frcSheet = ss.getSheetByName('FRC');
    if (!frcSheet) {
      Logger.log('‚ùå FRC sheet not found');
      return {
        matches: [],
        totalGuests: 0,
        error: 'FRC sheet not found'
      };
    }

    // Get FRC data
    const frcData = frcSheet.getDataRange().getValues();

    // Build map of checked-in guests with their data
    // KEY CHANGE: Use UID as the key (not Screen Name) because Screen Names can change in FRC
    const checkedInGuests = {};
    let totalRows = 0;
    let checkedInCount = 0;
    let skippedNoName = 0;
    let skippedNoUID = 0;

    Logger.log('üîç Scanning FRC sheet for checked-in guests...');

    for (let i = 1; i < frcData.length; i++) {
      const row = frcData[i];
      totalRows++;

      const checkedInRaw = row[CONFIG.COL.CHECKED_IN] || '';
      const checkedIn = String(checkedInRaw).trim().toUpperCase();

      // Log first 5 rows to help debug
      if (i <= 5) {
        Logger.log('Row ' + (i + 1) + ' - Checked-In value: "' + checkedInRaw + '" ‚Üí "' + checkedIn + '"');
      }

      if (checkedIn === 'Y') {
        checkedInCount++;
        const screenName = String(row[CONFIG.COL.SCREEN_NAME] || '').trim();
        const uid = String(row[CONFIG.COL.UID] || '').trim();

        if (!screenName) {
          skippedNoName++;
          Logger.log('‚ö†Ô∏è Row ' + (i + 1) + ' has Checked-In=Y but missing Screen Name');
        }
        if (!uid) {
          skippedNoUID++;
          Logger.log('‚ö†Ô∏è Row ' + (i + 1) + ' has Checked-In=Y but missing UID');
        }

        if (screenName && uid) {
          // Use UID as key (stable identifier)
          checkedInGuests[uid] = {
            screenName: screenName,
            uid: uid,
            zodiac: String(row[CONFIG.COL.ZODIAC] || '---').trim(),
            music: String(row[CONFIG.COL.MUSIC] || '---').trim(),
            photoUrl: convertDriveUrlToDirectLink(String(row[CONFIG.COL.PHOTO_URL] || '').trim()),
            interests: [
              String(row[CONFIG.COL.INTEREST_1] || '').trim(),
              String(row[CONFIG.COL.INTEREST_2] || '').trim(),
              String(row[CONFIG.COL.INTEREST_3] || '').trim()
            ].filter(i => i !== '')
          };
        }
      }
    }

    const checkedInUIDs = Object.keys(checkedInGuests);
    Logger.log('üìä SCAN RESULTS:');
    Logger.log('   Total rows scanned: ' + totalRows);
    Logger.log('   Rows with Checked-In=Y: ' + checkedInCount);
    Logger.log('   Skipped (no Screen Name): ' + skippedNoName);
    Logger.log('   Skipped (no UID): ' + skippedNoUID);
    Logger.log('‚úÖ Valid checked-in guests: ' + checkedInUIDs.length);

    // DEBUG: Show discrepancy between checked-in rows and unique guests
    if (checkedInCount > checkedInUIDs.length) {
      Logger.log('‚ö†Ô∏è WARNING: ' + (checkedInCount - checkedInUIDs.length) + ' duplicate UIDs detected!');
      Logger.log('   This means multiple rows have the same UID (last occurrence wins)');
    }

    // DEBUG: Show first 10 valid guest names
    Logger.log('üìã First 10 valid checked-in guests:');
    checkedInUIDs.slice(0, 10).forEach((uid, idx) => {
      Logger.log('   ' + (idx + 1) + '. "' + checkedInGuests[uid].screenName + '" (UID: ' + uid + ')');
    });

    // REQUIREMENT: Need 6+ guests to start matching
    if (checkedInUIDs.length < 6) {
      return {
        matches: [],
        totalGuests: checkedInUIDs.length,
        message: 'Waiting for more guests... (' + checkedInUIDs.length + '/6 checked in)',
        minimumNotMet: true
      };
    }

    if (checkedInUIDs.length === 0) {
      return {
        matches: [],
        totalGuests: 0,
        message: 'No checked-in guests found'
      };
    }

    // Get Guest_Similarity matrix
    const simData = simSheet.getDataRange().getValues();
    const simHeaders = simData[0]; // Row 1: headers (Screen Name (UID))

    // Build column index map for checked-in guests by UID
    const guestColMap = {}; // Maps UID -> column index
    Logger.log('üîç Building column map from Guest_Similarity headers...');
    Logger.log('   Total headers in Guest_Similarity: ' + (simHeaders.length - 1));

    for (let col = 1; col < simHeaders.length; col++) {
      const header = String(simHeaders[col]).trim();
      // Extract UID from "Screen Name (UID)" format
      const match = header.match(/\(([^)]+)\)$/);
      if (match) {
        const uid = match[1].trim();
        if (checkedInGuests[uid]) {
          guestColMap[uid] = col;
        }
      }
    }

    Logger.log('   ‚úÖ Matched columns for ' + Object.keys(guestColMap).length + ' checked-in guests');

    // DEBUG: Show first few checked-in guests and first few similarity headers
    if (Object.keys(guestColMap).length < checkedInUIDs.length) {
      Logger.log('‚ö†Ô∏è MISMATCH DETECTED:');
      Logger.log('   First 5 checked-in guests from FRC:');
      checkedInUIDs.slice(0, 5).forEach(uid =>
        Logger.log('     - "' + checkedInGuests[uid].screenName + '" (UID: ' + uid + ')')
      );
      Logger.log('   First 5 UIDs from Guest_Similarity headers:');
      for (let col = 1; col <= Math.min(5, simHeaders.length - 1); col++) {
        const header = String(simHeaders[col]).trim();
        const match = header.match(/\(([^)]+)\)$/);
        const uid = match ? match[1].trim() : 'NO_UID';
        const screenName = header.split(' (')[0].trim();
        Logger.log('     - "' + screenName + '" (UID: ' + uid + ') [header: "' + header + '"]');
      }
    }

    // Build row index map for checked-in guests by UID
    const guestRowMap = {}; // Maps UID -> row index
    for (let row = 1; row < simData.length; row++) {
      const rowHeader = String(simData[row][0]).trim();
      // Extract UID from "Screen Name (UID)" format
      const match = rowHeader.match(/\(([^)]+)\)$/);
      if (match) {
        const uid = match[1].trim();
        if (checkedInGuests[uid]) {
          guestRowMap[uid] = row;
        }
      }
    }

    Logger.log('   ‚úÖ Matched rows for ' + Object.keys(guestRowMap).length + ' checked-in guests');

    // Extract all similarity pairs for checked-in guests (using UIDs)
    const matches = [];
    const processedPairs = new Set();

    for (const uid1 of checkedInUIDs) {
      const row = guestRowMap[uid1];
      if (row === undefined) continue;

      for (const uid2 of checkedInUIDs) {
        if (uid1 === uid2) continue;

        const col = guestColMap[uid2];
        if (col === undefined) continue;

        // Create unique pair ID (alphabetical order to avoid duplicates)
        const pairId = [uid1, uid2].sort().join('|');
        if (processedPairs.has(pairId)) continue;
        processedPairs.add(pairId);

        // Get similarity score
        const similarity = parseFloat(simData[row][col]) || 0;

        // Calculate shared interests
        const interests1 = new Set(checkedInGuests[uid1].interests);
        const interests2 = new Set(checkedInGuests[uid2].interests);
        const sharedInterests = [...interests1].filter(i => interests2.has(i));

        matches.push({
          person1: checkedInGuests[uid1],
          person2: checkedInGuests[uid2],
          similarity: similarity, // Raw similarity (0.0 - 1.0)
          sharedInterests: sharedInterests
        });
      }
    }

    // Sort by similarity (highest first)
    matches.sort((a, b) => b.similarity - a.similarity);

    // Take top 150 matches, then shuffle to show variety each time
    const topMatches = matches.slice(0, 150);

    // Shuffle array using Fisher-Yates algorithm for randomization
    for (let i = topMatches.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [topMatches[i], topMatches[j]] = [topMatches[j], topMatches[i]];
    }

    // Return shuffled subset of 50 matches
    const displayMatches = topMatches.slice(0, 50);

    Logger.log('‚úÖ Generated ' + displayMatches.length + ' matches from ' + checkedInUIDs.length + ' checked-in guests');

    return {
      matches: displayMatches,
      totalGuests: checkedInUIDs.length
    };

  } catch (error) {
    Logger.log('‚ùå Error in getCompatibilityMatches: ' + error.toString());
    Logger.log('Stack: ' + error.stack);
    return {
      matches: [],
      totalGuests: 0,
      error: error.toString()
    };
  }
}

/**
 * Sync photos from Drive - convert sharing URLs to direct thumbnail links
 * 
 * Updates FRC sheet Photo URL column (AD) with optimized thumbnail links
 * for faster loading in the MM page.
 * 
 * @return {Object} {success: Boolean, updated: Number, message: String}
 */
function syncPhotosFromDrive() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const frcSheet = ss.getSheetByName('FRC');

    if (!frcSheet) {
      return { success: false, message: 'FRC sheet not found' };
    }

    const data = frcSheet.getDataRange().getValues();
    const photoUrlCol = CONFIG.COL.PHOTO_URL;

    let updatedCount = 0;

    for (let i = 1; i < data.length; i++) {
      const currentUrl = data[i][photoUrlCol];

      if (currentUrl && typeof currentUrl === 'string' && currentUrl.includes('drive.google.com')) {
        // Skip if already in thumbnail format
        if (currentUrl.includes('/thumbnail?id=')) {
          continue;
        }

        // Convert any other Drive URL format to thumbnail
        const thumbnailUrl = convertDriveUrlToDirectLink(currentUrl);

        if (thumbnailUrl !== currentUrl) {
          frcSheet.getRange(i + 1, photoUrlCol + 1).setValue(thumbnailUrl);
          updatedCount++;
          Logger.log('Row ' + (i + 1) + ': Updated photo URL');
        }
      }
    }

    Logger.log('‚úÖ Photo sync complete: ' + updatedCount + ' URLs converted');

    return {
      success: true,
      updated: updatedCount,
      message: 'Successfully converted ' + updatedCount + ' photo URLs'
    };

  } catch (error) {
    Logger.log('‚ùå Error: ' + error.toString());
    return { success: false, message: error.toString() };
  }
}

/**
 * Convert Drive sharing URLs to direct thumbnail links
 * 
 * Extracts file ID from various Drive URL formats and converts to optimized
 * thumbnail link for use in <img> tags.
 * 
 * Supported formats:
 * - /file/d/FILEID/view
 * - ?id=FILEID
 * - /uc?export=view&id=FILEID
 * 
 * @param {String} driveUrl - Original Drive URL
 * @return {String} Thumbnail URL or original URL if conversion fails
 */
function convertDriveUrlToDirectLink(driveUrl) {
  if (!driveUrl || driveUrl === '') return '';

  try {
    let fileId = null;

    // Format 1: /file/d/FILEID/view or /file/d/FILEID
    let match = driveUrl.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
    if (match) {
      fileId = match[1];
    }

    // Format 2: ?id=FILEID or &id=FILEID
    if (!fileId) {
      match = driveUrl.match(/[?&]id=([a-zA-Z0-9_-]+)/);
      if (match) {
        fileId = match[1];
      }
    }

    // If we found a file ID, return thumbnail link
    if (fileId) {
      return 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w500';
    }

    // If already a thumbnail link, return as-is
    if (driveUrl.includes('drive.google.com/thumbnail')) {
      return driveUrl;
    }

    // If old format (/uc?export=view), convert to thumbnail
    if (driveUrl.includes('drive.google.com/uc?export=view')) {
      const match2 = driveUrl.match(/[?&]id=([a-zA-Z0-9_-]+)/);
      if (match2) {
        return 'https://drive.google.com/thumbnail?id=' + match2[1] + '&sz=w500';
      }
    }

    return driveUrl;

  } catch (error) {
    Logger.log('‚ùå Error converting Drive URL: ' + error.toString());
    return driveUrl;
  }
}

/**
 * ============================================================================
 * LIVE ANALYTICS FUNCTIONS - Halloween Matcher
 * ============================================================================
 */

/**
 * Get complete live analytics package for MM page
 * Combines all metrics in one call for efficiency
 * 
 * PRIVACY: Excludes gender, ethnicity, sexual orientation
 */
function getLiveAnalytics() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const frcSheet = ss.getSheetByName('FRC');
    
    if (!frcSheet) {
      return { error: 'FRC sheet not found' };
    }

    // Get checked-in guests data
    const frcData = frcSheet.getDataRange().getValues();
    const checkedInGuests = [];
    
    for (let i = 1; i < frcData.length; i++) {
      const row = frcData[i];
      if (String(row[CONFIG.COL.CHECKED_IN] || '').trim().toUpperCase() === 'Y') {
        checkedInGuests.push({
          screenName: String(row[CONFIG.COL.SCREEN_NAME] || '').trim(),
          uid: String(row[CONFIG.COL.UID] || '').trim(),
          zodiac: String(row[CONFIG.COL.ZODIAC] || '').trim(),
          ageRange: String(row[CONFIG.COL.AGE] || '').trim(),
          education: String(row[CONFIG.COL.EDU] || '').trim(),
          industry: String(row[CONFIG.COL.INDUSTRY] || '').trim(),
          music: String(row[CONFIG.COL.MUSIC] || '').trim(),
          recentPurchase: String(row[CONFIG.COL.RECENT_PURCHASE] || '').trim(),
          socialStance: String(row[CONFIG.COL.SOCIAL_STANCE] || '').trim(),
          photoUrl: String(row[CONFIG.COL.PHOTO_URL] || '').trim(),
          checkinTime: row[CONFIG.COL.CHECKIN_TIME] ? new Date(row[CONFIG.COL.CHECKIN_TIME]).getTime() : null,
          interests: [
            String(row[CONFIG.COL.INTEREST_1] || '').trim(),
            String(row[CONFIG.COL.INTEREST_2] || '').trim(),
            String(row[CONFIG.COL.INTEREST_3] || '').trim()
          ].filter(i => i !== '')
        });
      }
    }

    if (checkedInGuests.length < 6) {
      return {
        minimumNotMet: true,
        guestCount: checkedInGuests.length,
        message: 'Waiting for more guests... (' + checkedInGuests.length + '/6)'
      };
    }

    // Compute all analytics
    const superlatives = computeSuperlatives(checkedInGuests);
    const partyStats = computePartyStats(checkedInGuests);
    const cramersV = computeCramersVSnapshot(checkedInGuests);
    const tagLifts = computeTagLifts(checkedInGuests);
    const activity = getActivityStream(checkedInGuests);
    
    return {
      guestCount: checkedInGuests.length,
      superlatives: superlatives,
      partyStats: partyStats,
      cramersV: cramersV,
      tagLifts: tagLifts,
      activity: activity,
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    Logger.log('‚ùå Error in getLiveAnalytics: ' + error.toString());
    return { error: error.toString() };
  }
}

/**
 * Compute superlatives (leaderboard items)
 * PRIVACY-SAFE: No gender/ethnicity
 *
 * Computes 8 superlative types:
 * 1. Best Overall Match - highest compatibility score
 * 2. Most Popular Guest - appears in most pairings
 * 3. Most Shared Interest - most common interest across guests
 * 4. Strongest Cohort Link - highest Cram√©r's V between categories
 * 5. Most Unlikely Connection - high match despite uncorrelated categories
 * 6. Fastest New Connection - first pair to match after check-in
 * 7. Analytical Oddity - prediction vs actual mismatch
 * 8. Social Butterfly - bridges most clusters
 */
function computeSuperlatives(guests) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const simSheet = ss.getSheetByName('Guest_Similarity');

    if (!simSheet || guests.length < 2) {
      return {
        bestOverallMatch: null,
        mostPopularGuest: null,
        mostSharedInterest: null,
        strongestCohortLink: null,
        mostUnlikelyConnection: null,
        fastestNewConnection: null,
        analyticalOddity: null,
        socialButterfly: null
      };
    }

    const simData = simSheet.getDataRange().getValues();
    const simHeaders = simData[0];

    // Build guest index maps
    const guestMap = {};
    guests.forEach(g => { guestMap[g.screenName] = g; });

    const guestColMap = {};
    const guestRowMap = {};

    for (let col = 1; col < simHeaders.length; col++) {
      const name = String(simHeaders[col]).split(' (')[0];
      if (guestMap[name]) guestColMap[name] = col;
    }

    for (let row = 1; row < simData.length; row++) {
      const name = String(simData[row][0]).split(' (')[0];
      if (guestMap[name]) guestRowMap[name] = row;
    }

    // ========================================================================
    // 1. BEST OVERALL MATCH - highest compatibility score
    // ========================================================================
    let bestOverallMatch = { score: 0, pair: [] };
    const appealCounts = {};
    const allPairs = [];

    for (const g1 of guests) {
      appealCounts[g1.screenName] = 0;
      const row = guestRowMap[g1.screenName];
      if (!row) continue;

      for (const g2 of guests) {
        if (g1.screenName >= g2.screenName) continue;
        const col = guestColMap[g2.screenName];
        if (!col) continue;

        const sim = parseFloat(simData[row][col]) || 0;

        if (sim > 0.5) {
          appealCounts[g1.screenName]++;
          appealCounts[g2.screenName] = (appealCounts[g2.screenName] || 0) + 1;
        }

        allPairs.push({ g1, g2, sim });

        if (sim > bestOverallMatch.score) {
          bestOverallMatch = { score: sim, pair: [g1.screenName, g2.screenName] };
        }
      }
    }

    // ========================================================================
    // 2. MOST POPULAR GUEST - appears in most pairings (> 50% similarity)
    // ========================================================================
    let mostPopularGuest = { name: '', count: 0 };
    for (const name in appealCounts) {
      if (appealCounts[name] > mostPopularGuest.count) {
        mostPopularGuest = { name: name, count: appealCounts[name] };
      }
    }

    // ========================================================================
    // 3. MOST SHARED INTEREST - most common interest across all guests
    // ========================================================================
    const interestCounts = {};
    guests.forEach(g => {
      g.interests.forEach(int => {
        interestCounts[int] = (interestCounts[int] || 0) + 1;
      });
    });

    let mostSharedInterest = { interest: '', count: 0, pct: 0 };
    for (const int in interestCounts) {
      if (interestCounts[int] > mostSharedInterest.count) {
        mostSharedInterest = {
          interest: int,
          count: interestCounts[int],
          pct: Math.round(interestCounts[int] / guests.length * 100)
        };
      }
    }

    // ========================================================================
    // 4. STRONGEST COHORT LINK - highest Cram√©r's V between categories
    // ========================================================================
    const cohortPairs = [
      { name: 'Music ‚Üî Interests', v: computePairwiseV(guests, 'music', 'interests') },
      { name: 'Zodiac ‚Üî Music', v: computePairwiseV(guests, 'zodiac', 'music') },
      { name: 'Industry ‚Üî Education', v: computePairwiseV(guests, 'industry', 'education') },
      { name: 'Age ‚Üî Music', v: computePairwiseV(guests, 'ageRange', 'music') },
      { name: 'Social ‚Üî Interests', v: computePairwiseV(guests, 'socialStance', 'interests') },
      { name: 'Education ‚Üî Music', v: computePairwiseV(guests, 'education', 'music') }
    ];
    cohortPairs.sort((a, b) => b.v - a.v);
    const strongestCohortLink = cohortPairs[0];

    // ========================================================================
    // 5. MOST UNLIKELY CONNECTION - high match despite uncorrelated categories
    // ========================================================================
    let mostUnlikelyConnection = null;
    let unlikelyScore = 0;

    for (const pair of allPairs) {
      // High similarity but different categories
      if (pair.sim > 0.6) {
        let differences = 0;
        if (pair.g1.ageRange !== pair.g2.ageRange) differences++;
        if (pair.g1.education !== pair.g2.education) differences++;
        if (pair.g1.industry !== pair.g2.industry) differences++;
        if (pair.g1.music !== pair.g2.music) differences++;
        if (pair.g1.zodiac !== pair.g2.zodiac) differences++;

        const unlikelyMetric = pair.sim * differences;
        if (unlikelyMetric > unlikelyScore) {
          unlikelyScore = unlikelyMetric;
          mostUnlikelyConnection = {
            name1: pair.g1.screenName,
            name2: pair.g2.screenName,
            score: Math.round((pair.sim + 0.1) * 100),
            differences: differences
          };
        }
      }
    }

    // ========================================================================
    // 6. FASTEST NEW CONNECTION - first pair to match after check-in
    // ========================================================================
    let fastestNewConnection = null;
    if (guests.length >= 2) {
      // Sort by check-in time
      const sorted = guests.filter(g => g.checkinTime).sort((a, b) => b.checkinTime - a.checkinTime);

      if (sorted.length >= 2) {
        // Get the two most recent check-ins
        const recent1 = sorted[0];
        const recent2 = sorted[1];

        const row = guestRowMap[recent1.screenName];
        const col = guestColMap[recent2.screenName];

        if (row && col) {
          const sim = parseFloat(simData[row][col]) || 0;
          fastestNewConnection = {
            name1: recent1.screenName,
            name2: recent2.screenName,
            score: Math.round((sim + 0.1) * 100),
            timeDiff: Math.abs(recent1.checkinTime - recent2.checkinTime) / 1000 / 60 // minutes
          };
        }
      }
    }

    // ========================================================================
    // 7. ANALYTICAL ODDITY - prediction vs actual mismatch
    // ========================================================================
    let analyticalOddity = null;
    let oddityScore = 0;

    // Find pairs with shared interests but low similarity (unexpected)
    for (const pair of allPairs) {
      const shared = pair.g1.interests.filter(i => pair.g2.interests.includes(i));
      if (shared.length >= 2 && pair.sim < 0.5) {
        const oddity = shared.length * (0.5 - pair.sim);
        if (oddity > oddityScore) {
          oddityScore = oddity;
          analyticalOddity = {
            name1: pair.g1.screenName,
            name2: pair.g2.screenName,
            score: Math.round((pair.sim + 0.1) * 100),
            sharedCount: shared.length
          };
        }
      }
    }

    // ========================================================================
    // 8. SOCIAL BUTTERFLY - bridges most clusters (high avg similarity)
    // ========================================================================
    const avgSimilarity = {};

    for (const g1 of guests) {
      const row = guestRowMap[g1.screenName];
      if (!row) continue;

      let totalSim = 0;
      let count = 0;

      for (const g2 of guests) {
        if (g1.screenName === g2.screenName) continue;
        const col = guestColMap[g2.screenName];
        if (!col) continue;

        const sim = parseFloat(simData[row][col]) || 0;
        totalSim += sim;
        count++;
      }

      avgSimilarity[g1.screenName] = count > 0 ? totalSim / count : 0;
    }

    let socialButterfly = { name: '', avgScore: 0, connections: 0 };
    for (const name in avgSimilarity) {
      if (avgSimilarity[name] > socialButterfly.avgScore) {
        socialButterfly = {
          name: name,
          avgScore: Math.round((avgSimilarity[name] + 0.1) * 100),
          connections: appealCounts[name] || 0
        };
      }
    }

    // ========================================================================
    // RETURN ALL 8 SUPERLATIVES
    // ========================================================================
    return {
      bestOverallMatch: bestOverallMatch.score > 0 ? {
        name1: bestOverallMatch.pair[0],
        name2: bestOverallMatch.pair[1],
        score: Math.round((bestOverallMatch.score + 0.1) * 100)
      } : null,

      mostPopularGuest: mostPopularGuest.count > 0 ? mostPopularGuest : null,

      mostSharedInterest: mostSharedInterest.count > 0 ? mostSharedInterest : null,

      strongestCohortLink: strongestCohortLink.v > 0 ? strongestCohortLink : null,

      mostUnlikelyConnection: mostUnlikelyConnection,

      fastestNewConnection: fastestNewConnection,

      analyticalOddity: analyticalOddity,

      socialButterfly: socialButterfly.avgScore > 0 ? socialButterfly : null
    };

  } catch (error) {
    Logger.log('‚ùå Error in computeSuperlatives: ' + error.toString());
    return {};
  }
}

/**
 * Compute party-wide statistics
 */
function computePartyStats(guests) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const simSheet = ss.getSheetByName('Guest_Similarity');
    
    if (!simSheet || guests.length < 2) {
      return { avgCompatibility: 0, distribution: [], topInterest: null };
    }
    
    const simData = simSheet.getDataRange().getValues();
    const simHeaders = simData[0];
    
    const guestMap = {};
    guests.forEach(g => { guestMap[g.screenName] = g; });
    
    const guestColMap = {};
    const guestRowMap = {};
    
    for (let col = 1; col < simHeaders.length; col++) {
      const name = String(simHeaders[col]).split(' (')[0];
      if (guestMap[name]) guestColMap[name] = col;
    }
    
    for (let row = 1; row < simData.length; row++) {
      const name = String(simData[row][0]).split(' (')[0];
      if (guestMap[name]) guestRowMap[name] = row;
    }
    
    // Calculate average compatibility
    let totalSim = 0;
    let pairCount = 0;
    const distribution = [0, 0, 0, 0, 0]; // 50-59, 60-69, 70-79, 80-89, 90-100
    
    for (const g1 of guests) {
      const row = guestRowMap[g1.screenName];
      if (!row) continue;
      
      for (const g2 of guests) {
        if (g1.screenName >= g2.screenName) continue;
        const col = guestColMap[g2.screenName];
        if (!col) continue;
        
        const sim = parseFloat(simData[row][col]) || 0;
        const displayScore = Math.round((sim + 0.1) * 100);
        totalSim += displayScore;
        pairCount++;
        
        if (displayScore >= 90) distribution[4]++;
        else if (displayScore >= 80) distribution[3]++;
        else if (displayScore >= 70) distribution[2]++;
        else if (displayScore >= 60) distribution[1]++;
        else if (displayScore >= 50) distribution[0]++;
      }
    }
    
    // Interest frequency
    const interestCounts = {};
    guests.forEach(g => {
      g.interests.forEach(int => {
        interestCounts[int] = (interestCounts[int] || 0) + 1;
      });
    });
    
    let topInterest = { name: '', count: 0 };
    for (const int in interestCounts) {
      if (interestCounts[int] > topInterest.count) {
        topInterest = { name: int, count: interestCounts[int], pct: Math.round(interestCounts[int] / guests.length * 100) };
      }
    }
    
    return {
      avgCompatibility: pairCount > 0 ? Math.round(totalSim / pairCount) : 0,
      distribution: [
        { range: '50-59%', count: distribution[0] },
        { range: '60-69%', count: distribution[1] },
        { range: '70-79%', count: distribution[2] },
        { range: '80-89%', count: distribution[3] },
        { range: '90-100%', count: distribution[4] }
      ],
      topInterest: topInterest.count > 0 ? topInterest : null,
      totalPairs: pairCount
    };
    
  } catch (error) {
    Logger.log('‚ùå Error in computePartyStats: ' + error.toString());
    return {};
  }
}

/**
 * Compute Cram√©r's V for privacy-safe features only
 * EXCLUDES: gender, ethnicity, sexual orientation
 * INCLUDES: zodiac, music, age, education, industry, social stance, interests
 */
function computeCramersVSnapshot(guests) {
  try {
    // Simple pairwise associations for display
    // Using contingency table approach
    
    const pairs = [
      { name: 'Music ‚Üî Interests', v: computePairwiseV(guests, 'music', 'interests') },
      { name: 'Zodiac ‚Üî Music', v: computePairwiseV(guests, 'zodiac', 'music') },
      { name: 'Industry ‚Üî Education', v: computePairwiseV(guests, 'industry', 'education') },
      { name: 'Age ‚Üî Music', v: computePairwiseV(guests, 'ageRange', 'music') },
      { name: 'Social ‚Üî Interests', v: computePairwiseV(guests, 'socialStance', 'interests') }
    ];
    
    pairs.sort((a, b) => b.v - a.v);
    
    return {
      top3: pairs.slice(0, 3),
      strongest: pairs[0]
    };
    
  } catch (error) {
    Logger.log('‚ùå Error in computeCramersVSnapshot: ' + error.toString());
    return { top3: [], strongest: null };
  }
}

/**
 * Helper: Compute Cram√©r's V between two features
 */
function computePairwiseV(guests, field1, field2) {
  // Simplified V calculation
  const counts = {};
  let total = 0;
  
  guests.forEach(g => {
    let val1 = g[field1];
    let val2 = field2 === 'interests' ? (g.interests[0] || 'None') : g[field2];
    
    if (!val1 || !val2) return;
    
    const key = val1 + '|' + val2;
    counts[key] = (counts[key] || 0) + 1;
    total++;
  });
  
  if (total < 10) return 0;
  
  // Rough approximation - return normalized association strength
  const uniqueKeys = Object.keys(counts).length;
  const expected = total / uniqueKeys;
  let chiSq = 0;
  
  for (const key in counts) {
    chiSq += Math.pow(counts[key] - expected, 2) / expected;
  }
  
  const v = Math.sqrt(chiSq / total);
  return Math.min(v, 1.0);
}

/**
 * Compute tag lifts (interest associations)
 */
function computeTagLifts(guests) {
  try {
    const interestPairs = {};
    
    // Count co-occurrences
    guests.forEach(g => {
      for (let i = 0; i < g.interests.length; i++) {
        for (let j = i + 1; j < g.interests.length; j++) {
          const pair = [g.interests[i], g.interests[j]].sort().join(' + ');
          interestPairs[pair] = (interestPairs[pair] || 0) + 1;
        }
      }
    });
    
    // Get top 5 lifts
    const lifts = Object.entries(interestPairs)
      .map(([pair, count]) => ({ pair, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);
    
    return lifts;
    
  } catch (error) {
    Logger.log('‚ùå Error in computeTagLifts: ' + error.toString());
    return [];
  }
}

/**
 * Get recent activity stream
 */
function getActivityStream(guests) {
  try {
    // Sort by check-in time
    const sorted = guests
      .filter(g => g.checkinTime)
      .sort((a, b) => b.checkinTime - a.checkinTime)
      .slice(0, 10);
    
    const now = Date.now();
    
    return sorted.map(g => ({
      screenName: g.screenName,
      action: 'checked in',
      timeAgo: Math.floor((now - g.checkinTime) / 1000) // seconds ago
    }));
    
  } catch (error) {
    Logger.log('‚ùå Error in getActivityStream: ' + error.toString());
    return [];
  }
}
