/**
 * ============================================================================
 * WALL DATA BACKEND (WallData.gs)
 * ============================================================================
 * Provides data endpoints for The Wall display
 * Separated from main Code.gs to keep systems modular
 */

// ============================================================================
// WALL DATA FETCHER
// ============================================================================

/**
 * Get all data needed for The Wall display
 * Returns: guests, connections by category, unknowns, stats
 */
function getWallData() {
  Logger.log('=== FETCHING WALL DATA ===');
  
  const guests = getCheckedInGuests();
  Logger.log(`Retrieved ${guests.length} checked-in guests`);
  
  // Identify unknown guests (don't know hosts)
  const unknownGuests = guests.filter(g => {
    const knowHosts = String(g.knowHosts || '').toLowerCase();
    const knownLongest = String(g.knownLongest || '').toLowerCase();
    
    return knowHosts.includes('no') || 
           knownLongest.includes('do not know') ||
           knownLongest === '';
  });
  
  Logger.log(`Found ${unknownGuests.length} unknown guests`);
  
  // Calculate arrival rate (last 30 min)
  const now = new Date();
  const thirtyMinAgo = new Date(now - 30 * 60 * 1000);
  const recentArrivals = guests.filter(g => {
    const checkInTime = new Date(g.checkInTime);
    return checkInTime > thirtyMinAgo;
  });
  
  // Format guest data for display
  const formattedGuests = guests.map(g => ({
    uid: g.uid,
    screenName: g.screenName,
    checkInTime: new Date(g.checkInTime).toLocaleTimeString(),
    checkInTimestamp: new Date(g.checkInTime).getTime(),
    photoUrl: g.photoUrl || '',
    isUnknown: unknownGuests.some(u => u.uid === g.uid),
    
    // Attributes for connection analysis
    age: g.age,
    interests: [g.interest1, g.interest2, g.interest3].filter(Boolean),
    music: g.music,
    zodiac: g.zodiac,
    industry: g.industry,
    education: g.education,
    orientation: g.orientation,
    socialStance: g.socialStance,
    atWorst: g.atWorst
  }));
  
  // Build connections by category
  const connectionsByCategory = buildConnectionsByCategory(formattedGuests);
  
  return {
    guests: formattedGuests,
    connectionsByCategory: connectionsByCategory,
    unknownGuests: unknownGuests.map(u => ({
      uid: u.uid,
      screenName: u.screenName
    })),
    stats: {
      totalGuests: guests.length,
      totalUnknowns: unknownGuests.length,
      recentArrivals: recentArrivals.length,
      lastCheckIn: guests.length > 0 ? 
        Math.max(...guests.map(g => new Date(g.checkInTime).getTime())) : 0
    }
  };
}

/**
 * Build connections organized by category and subcategory
 * EXCLUDES sexual orientation for privacy
 */
function buildConnectionsByCategory(guests) {
  Logger.log('Building connections by category...');
  
  const connections = {
    age: buildAgeConnections(guests),
    interests: buildInterestConnections(guests),
    music: buildMusicConnections(guests),
    zodiac: buildZodiacConnections(guests),
    industry: buildIndustryConnections(guests),
    education: buildEducationConnections(guests),
    socialStance: buildSocialStanceConnections(guests),
    compatibility: buildCompatibilityConnections(guests),
    danceTeams: buildDanceTeamConnections(guests)
    // Note: orientation connections excluded for privacy
  };
  
  return connections;
}

/**
 * Build connections for age groups
 */
function buildAgeConnections(guests) {
  const ageGroups = {};
  
  guests.forEach(guest => {
    if (!guest.age) return;
    
    if (!ageGroups[guest.age]) {
      ageGroups[guest.age] = [];
    }
    ageGroups[guest.age].push(guest.uid);
  });
  
  // Create connections within each age group
  const connections = {};
  Object.keys(ageGroups).forEach(ageGroup => {
    const uids = ageGroups[ageGroup];
    connections[ageGroup] = [];
    
    // Connect all pairs within the group
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[ageGroup].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for shared interests
 */
function buildInterestConnections(guests) {
  const interestGroups = {};
  
  guests.forEach(guest => {
    guest.interests.forEach(interest => {
      if (!interest) return;
      
      if (!interestGroups[interest]) {
        interestGroups[interest] = [];
      }
      interestGroups[interest].push(guest.uid);
    });
  });
  
  const connections = {};
  Object.keys(interestGroups).forEach(interest => {
    const uids = interestGroups[interest];
    connections[interest] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[interest].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for music preferences
 */
function buildMusicConnections(guests) {
  const musicGroups = {};
  
  guests.forEach(guest => {
    if (!guest.music) return;
    
    if (!musicGroups[guest.music]) {
      musicGroups[guest.music] = [];
    }
    musicGroups[guest.music].push(guest.uid);
  });
  
  const connections = {};
  Object.keys(musicGroups).forEach(music => {
    const uids = musicGroups[music];
    connections[music] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[music].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for zodiac signs
 */
function buildZodiacConnections(guests) {
  const zodiacGroups = {};
  
  guests.forEach(guest => {
    if (!guest.zodiac) return;
    
    if (!zodiacGroups[guest.zodiac]) {
      zodiacGroups[guest.zodiac] = [];
    }
    zodiacGroups[guest.zodiac].push(guest.uid);
  });
  
  const connections = {};
  Object.keys(zodiacGroups).forEach(zodiac => {
    const uids = zodiacGroups[zodiac];
    connections[zodiac] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[zodiac].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for industries
 */
function buildIndustryConnections(guests) {
  const industryGroups = {};
  
  guests.forEach(guest => {
    if (!guest.industry) return;
    
    if (!industryGroups[guest.industry]) {
      industryGroups[guest.industry] = [];
    }
    industryGroups[guest.industry].push(guest.uid);
  });
  
  const connections = {};
  Object.keys(industryGroups).forEach(industry => {
    const uids = industryGroups[industry];
    connections[industry] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[industry].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for education levels
 */
function buildEducationConnections(guests) {
  const eduGroups = {};
  
  guests.forEach(guest => {
    if (!guest.education) return;
    
    if (!eduGroups[guest.education]) {
      eduGroups[guest.education] = [];
    }
    eduGroups[guest.education].push(guest.uid);
  });
  
  const connections = {};
  Object.keys(eduGroups).forEach(edu => {
    const uids = eduGroups[edu];
    connections[edu] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[edu].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for orientation
 */
function buildOrientationConnections(guests) {
  const orientationGroups = {};
  
  guests.forEach(guest => {
    if (!guest.orientation) return;
    
    if (!orientationGroups[guest.orientation]) {
      orientationGroups[guest.orientation] = [];
    }
    orientationGroups[guest.orientation].push(guest.uid);
  });
  
  const connections = {};
  Object.keys(orientationGroups).forEach(orientation => {
    const uids = orientationGroups[orientation];
    connections[orientation] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[orientation].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Build connections for social stance (similar values)
 */
function buildSocialStanceConnections(guests) {
  // Group by ranges: 1-2, 3-4, 5-6, 7-8, 9-10
  const stanceGroups = {
    '1-2': [],
    '3-4': [],
    '5-6': [],
    '7-8': [],
    '9-10': []
  };
  
  guests.forEach(guest => {
    if (!guest.socialStance) return;
    
    const stance = parseInt(guest.socialStance);
    if (stance >= 1 && stance <= 2) stanceGroups['1-2'].push(guest.uid);
    else if (stance >= 3 && stance <= 4) stanceGroups['3-4'].push(guest.uid);
    else if (stance >= 5 && stance <= 6) stanceGroups['5-6'].push(guest.uid);
    else if (stance >= 7 && stance <= 8) stanceGroups['7-8'].push(guest.uid);
    else if (stance >= 9 && stance <= 10) stanceGroups['9-10'].push(guest.uid);
  });
  
  const connections = {};
  Object.keys(stanceGroups).forEach(range => {
    const uids = stanceGroups[range];
    connections[range] = [];
    
    for (let i = 0; i < uids.length; i++) {
      for (let j = i + 1; j < uids.length; j++) {
        connections[range].push({
          source: uids[i],
          target: uids[j]
        });
      }
    }
  });
  
  return connections;
}

/**
 * Find the reason for a match between two guests
 * Returns shared interest, age, music, etc.
 */
function findMatchReason(guest1, guest2) {
  if (!guest1 || !guest2) return 'Compatible';

  // Check for shared interests (highest priority)
  const interests1 = guest1.interests || [];
  const interests2 = guest2.interests || [];
  for (let int of interests1) {
    if (interests2.includes(int)) {
      return int;
    }
  }

  // Check for same music
  if (guest1.music && guest2.music && guest1.music === guest2.music) {
    return guest1.music;
  }

  // Check for same age
  if (guest1.age && guest2.age && guest1.age === guest2.age) {
    return guest1.age;
  }

  // Check for same zodiac
  if (guest1.zodiac && guest2.zodiac && guest1.zodiac === guest2.zodiac) {
    return guest1.zodiac;
  }

  // Check for same industry
  if (guest1.industry && guest2.industry && guest1.industry === guest2.industry) {
    return guest1.industry;
  }

  return 'Compatible';
}

/**
 * Build compatibility connections from Guest_Similarity matrix
 * Shows backend MM (Match Maker) analysis in action
 */
function buildCompatibilityConnections(guests) {
  Logger.log('Building compatibility connections from Guest_Similarity matrix...');

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const simSheet = ss.getSheetByName('Guest_Similarity');

    if (!simSheet) {
      Logger.log('❌ Guest_Similarity sheet not found - skipping compatibility connections');
      return { 'No Data': [] };
    }

    // Get all data from similarity matrix
    const simData = simSheet.getDataRange().getValues();

    // Row 1 = UIDs, Column A = UIDs
    const uids = simData[0].slice(1); // Skip first cell

    // Build UID to index map
    const uidToIndex = {};
    uids.forEach((uid, i) => {
      uidToIndex[String(uid)] = i;
    });

    // Get checked-in UIDs
    const checkedInUids = guests.map(g => String(g.uid));

    // Extract similarity pairs for checked-in guests
    const matches = [];

    for (let i = 0; i < checkedInUids.length; i++) {
      for (let j = i + 1; j < checkedInUids.length; j++) {
        const uid1 = checkedInUids[i];
        const uid2 = checkedInUids[j];

        const idx1 = uidToIndex[uid1];
        const idx2 = uidToIndex[uid2];

        if (idx1 !== undefined && idx2 !== undefined) {
          // Get similarity score from matrix
          const row = idx1 + 1; // +1 for header row
          const col = idx2 + 1; // +1 for UID column

          const similarity = parseFloat(simData[row][col]) || 0;

          if (similarity > 0) {
            // Find reason for match (shared interests)
            const guest1 = guests.find(g => String(g.uid) === uid1);
            const guest2 = guests.find(g => String(g.uid) === uid2);
            const reason = findMatchReason(guest1, guest2);

            matches.push({
              source: uid1,
              target: uid2,
              similarity: similarity,
              reason: reason
            });
          }
        }
      }
    }

    // Sort by similarity (highest first) and take top 15
    matches.sort((a, b) => b.similarity - a.similarity);
    const topMatches = matches.slice(0, 15);

    Logger.log(`✓ Found ${topMatches.length} top compatibility matches`);

    // Return all 15 matches as single category for stepwise Wall display
    const connections = {
      'Guest Matches': topMatches.map(match => ({
        source: match.source,
        target: match.target,
        similarity: match.similarity, // Include score for line thickness
        reason: match.reason // Include reason for display
      }))
    };

    return connections;

  } catch (error) {
    Logger.log('❌ Error building compatibility connections: ' + error.toString());
    return { 'Error': [] };
  }
}

/**
 * Build dance team pyramid connections from ALM analysis
 * Shows backend ALM (Dance Team Generator) pyramid matchmaking
 */
function buildDanceTeamConnections(guests) {
  Logger.log('Building dance team pyramid connections...');

  // Need at least 6 dancers for one team
  if (guests.length < 6) {
    Logger.log('⚠️ Not enough dancers for team building (need 6+)');
    return { 'Insufficient Dancers': [] };
  }

  try {
    // Generate 15 dance teams (backend visualization)
    // People can repeat across teams, but each focal is unique
    const teamsToShow = Math.min(15, guests.length); // Show 15 teams
    const connections = {};
    const usedFocals = new Set();

    // Shuffle guests for randomness
    const shuffledGuests = [...guests].sort(() => Math.random() - 0.5);

    for (let teamNum = 0; teamNum < teamsToShow; teamNum++) {
      // Pick a random focal dancer (not used in previous teams)
      let focal = null;
      for (let guest of shuffledGuests) {
        if (!usedFocals.has(guest.uid)) {
          focal = guest;
          usedFocals.add(guest.uid);
          break;
        }
      }

      if (!focal) break; // No more unique focals available

      // Calculate similarities to focal
      const similarities = [];
      guests.forEach(guest => {
        if (guest.uid === focal.uid) return;

        const sim = calculateDancerSimilarity(focal, guest);
        similarities.push({
          uid: guest.uid,
          screenName: guest.screenName,
          similarity: sim
        });
      });

      // Sort by similarity
      similarities.sort((a, b) => b.similarity - a.similarity);

      // Select team members: top 5 matches (allowing people to repeat across teams)
      const teamMembers = similarities.slice(0, Math.min(5, similarities.length));

      // Generate team name based on focal's attributes
      const teamName = generateSimpleTeamName(focal, teamNum + 1);
      connections[teamName] = [];

      // Focal → Team member connections (all connections in pyramid)
      teamMembers.forEach((dancer, idx) => {
        const dancerGuest = guests.find(g => g.uid === dancer.uid);
        const reason = findMatchReason(focal, dancerGuest);
        connections[teamName].push({
          source: focal.uid,
          target: dancer.uid,
          similarity: dancer.similarity,
          tier: idx < 2 ? 'row2' : 'row3', // First 2 are row2, rest are row3
          reason: reason
        });
      });
    }

    Logger.log(`✓ Generated ${teamsToShow} dance team pyramids for Wall backend visualization`);
    return connections;

  } catch (error) {
    Logger.log('❌ Error building dance team connections: ' + error.toString());
    return { 'Error': [] };
  }
}

/**
 * Generate simple team name for Wall display
 */
function generateSimpleTeamName(focal, teamNumber) {
  const teamNames = [
    'Elite Squad', 'Dream Team', 'Power Crew', 'Star Force', 'Rising Stars',
    'Dynamic Five', 'Rhythm Squad', 'Energy Crew', 'Vibe Tribe', 'Flow Team',
    'Beat Squad', 'Move Makers', 'Dance Force', 'Stage Elite', 'Groove Gang'
  ];

  // Use team number to pick name, wrapping if needed
  const baseName = teamNames[(teamNumber - 1) % teamNames.length];
  return `${baseName} #${teamNumber}`;
}

/**
 * Calculate similarity between two dancers (simplified ALM algorithm)
 */
function calculateDancerSimilarity(dancerA, dancerB) {
  let matches = 0;
  let comparisons = 0;

  // Interest overlap (2x weight)
  const interestsA = dancerA.interests || [];
  const interestsB = dancerB.interests || [];

  interestsA.forEach(intA => {
    if (interestsB.includes(intA)) {
      matches += 2;
    }
  });
  comparisons += 6; // Max 3 interests * 2 weight

  // Age range match
  if (dancerA.age && dancerB.age) {
    comparisons += 1;
    if (dancerA.age === dancerB.age) {
      matches += 1;
    }
  }

  // Music preference
  if (dancerA.music && dancerB.music) {
    comparisons += 1;
    if (dancerA.music === dancerB.music) {
      matches += 0.5;
    } else {
      matches += 0.3; // Diversity bonus
    }
  }

  return comparisons > 0 ? matches / comparisons : 0;
}

// ============================================================================
// TEST FUNCTIONS
// ============================================================================

/**
 * Test the wall data fetcher
 */
function testWallData() {
  Logger.log('=== TESTING WALL DATA ===\n');
  
  const wallData = getWallData();
  
  Logger.log(`Total Guests: ${wallData.stats.totalGuests}`);
  Logger.log(`Unknown Guests: ${wallData.stats.totalUnknowns}`);
  Logger.log(`Recent Arrivals (30min): ${wallData.stats.recentArrivals}`);
  
  Logger.log('\n=== CONNECTION SUMMARY ===');
  Object.keys(wallData.connectionsByCategory).forEach(category => {
    const subCategories = wallData.connectionsByCategory[category];
    const totalConnections = Object.values(subCategories)
      .reduce((sum, conns) => sum + conns.length, 0);
    
    Logger.log(`${category}: ${Object.keys(subCategories).length} subcategories, ${totalConnections} connections`);
  });
  
  Logger.log('\n=== SAMPLE GUEST ===');
  if (wallData.guests.length > 0) {
    Logger.log(JSON.stringify(wallData.guests[0], null, 2));
  }
  
  Logger.log('\n=== UNKNOWN GUESTS ===');
  wallData.unknownGuests.forEach(u => {
    Logger.log(`⚠️ ${u.uid} - ${u.screenName}`);
  });
  
  return wallData;
}

/**
 * Test connection building for specific category
 */
function testCategoryConnections(category) {
  const guests = getCheckedInGuests().slice(0, 10); // Test with first 10
  
  const formattedGuests = guests.map(g => ({
    uid: g.uid,
    age: g.age,
    interests: [g.interest1, g.interest2, g.interest3].filter(Boolean),
    music: g.music,
    zodiac: g.zodiac,
    industry: g.industry,
    education: g.education,
    orientation: g.orientation,
    socialStance: g.socialStance
  }));
  
  let connections;
  switch(category) {
    case 'age':
      connections = buildAgeConnections(formattedGuests);
      break;
    case 'interests':
      connections = buildInterestConnections(formattedGuests);
      break;
    case 'music':
      connections = buildMusicConnections(formattedGuests);
      break;
    default:
      Logger.log('Unknown category');
      return;
  }
  
  Logger.log(`=== ${category.toUpperCase()} CONNECTIONS ===`);
  Logger.log(JSON.stringify(connections, null, 2));
  
  return connections;
}

/**
 * COMPREHENSIVE TEST SUITE
 * Run all tests and display results
 */
function runAllWallTests() {
  Logger.log('╔════════════════════════════════════════════════════════════════╗');
  Logger.log('║          WALL SYSTEM - COMPREHENSIVE TEST SUITE               ║');
  Logger.log('╚════════════════════════════════════════════════════════════════╝\n');
  
  const results = {
    passed: 0,
    failed: 0,
    tests: []
  };
  
  // Test 1: Data Retrieval
  try {
    Logger.log('TEST 1: Data Retrieval');
    const wallData = getWallData();
    if (wallData && wallData.guests && wallData.guests.length > 0) {
      Logger.log('✅ PASS: Retrieved wall data successfully');
      Logger.log(`   - ${wallData.guests.length} guests loaded`);
      results.passed++;
      results.tests.push({name: 'Data Retrieval', status: 'PASS'});
    } else {
      throw new Error('No guest data returned');
    }
  } catch (e) {
    Logger.log('❌ FAIL: ' + e.message);
    results.failed++;
    results.tests.push({name: 'Data Retrieval', status: 'FAIL', error: e.message});
  }
  
  // Test 2: Unknown Guest Detection
  try {
    Logger.log('\nTEST 2: Unknown Guest Detection');
    const wallData = getWallData();
    Logger.log(`✅ PASS: Detected ${wallData.unknownGuests.length} unknown guests`);
    wallData.unknownGuests.slice(0, 3).forEach(u => {
      Logger.log(`   - ${u.uid}: ${u.screenName}`);
    });
    results.passed++;
    results.tests.push({name: 'Unknown Guest Detection', status: 'PASS'});
  } catch (e) {
    Logger.log('❌ FAIL: ' + e.message);
    results.failed++;
    results.tests.push({name: 'Unknown Guest Detection', status: 'FAIL', error: e.message});
  }
  
  // Test 3: Age Connections
  try {
    Logger.log('\nTEST 3: Age Group Connections');
    const wallData = getWallData();
    const ageConnections = wallData.connectionsByCategory.age;
    const totalAge = Object.values(ageConnections).reduce((sum, c) => sum + c.length, 0);
    Logger.log(`✅ PASS: Built ${totalAge} age-based connections`);
    Logger.log(`   - Age groups: ${Object.keys(ageConnections).join(', ')}`);
    results.passed++;
    results.tests.push({name: 'Age Connections', status: 'PASS'});
  } catch (e) {
    Logger.log('❌ FAIL: ' + e.message);
    results.failed++;
    results.tests.push({name: 'Age Connections', status: 'FAIL', error: e.message});
  }
  
  // Test 4: Interest Connections
  try {
    Logger.log('\nTEST 4: Interest Connections');
    const wallData = getWallData();
    const interestConnections = wallData.connectionsByCategory.interests;
    const totalInterests = Object.values(interestConnections).reduce((sum, c) => sum + c.length, 0);
    Logger.log(`✅ PASS: Built ${totalInterests} interest-based connections`);
    Logger.log(`   - Interests: ${Object.keys(interestConnections).join(', ')}`);
    results.passed++;
    results.tests.push({name: 'Interest Connections', status: 'PASS'});
  } catch (e) {
    Logger.log('❌ FAIL: ' + e.message);
    results.failed++;
    results.tests.push({name: 'Interest Connections', status: 'FAIL', error: e.message});
  }
  
  // Test 5: Music Connections
  try {
    Logger.log('\nTEST 5: Music Preference Connections');
    const wallData = getWallData();
    const musicConnections = wallData.connectionsByCategory.music;
    const totalMusic = Object.values(musicConnections).reduce((sum, c) => sum + c.length, 0);
    Logger.log(`✅ PASS: Built ${totalMusic} music-based connections`);
    Logger.log(`   - Music types: ${Object.keys(musicConnections).slice(0, 5).join(', ')}...`);
    results.passed++;
    results.tests.push({name: 'Music Connections', status: 'PASS'});
  } catch (e) {
    Logger.log('❌ FAIL: ' + e.message);
    results.failed++;
    results.tests.push({name: 'Music Connections', status: 'FAIL', error: e.message});
  }
  
  // Summary
  Logger.log('\n╔════════════════════════════════════════════════════════════════╗');
  Logger.log('║                        TEST SUMMARY                            ║');
  Logger.log('╚════════════════════════════════════════════════════════════════╝');
  Logger.log(`Total Tests: ${results.passed + results.failed}`);
  Logger.log(`✅ Passed: ${results.passed}`);
  Logger.log(`❌ Failed: ${results.failed}`);
  Logger.log(`Success Rate: ${Math.round((results.passed / (results.passed + results.failed)) * 100)}%`);
  
  try {
    SpreadsheetApp.getUi().alert(
      '🧪 Wall System Tests Complete',
      `Passed: ${results.passed}/${results.passed + results.failed}\n\n` +
      'Check execution log for detailed results.',
      SpreadsheetApp.getUi().ButtonSet.OK
    );
  } catch (e) {}
  
  return results;
}
