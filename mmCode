
// ============================================
// PARTY EVENT MANAGEMENT SYSTEM - Code.gs
// ============================================
// Purpose: Backend for guest check-in web application
// Created: 2025
// Last Modified: [Update when you make changes]
//
// FEATURES:
// - Guest check-in via web form (ZIP, Gender, DOB verification)
// - Screen name updates after check-in
// - Photo uploads to Google Drive
// - Real-time spreadsheet updates
//
// WORKFLOW:
// 1. Form Responses 1: Original form data with "Checked-In" pre-approval column
// 2. Run DataClean.gs: Filters guests with "Checked-In" = "Y" → creates Form Responses (Clean)
// 3. Form Responses (Clean): Has columns 24-26 (Checked-In at Event, Timestamp, Photo URL)
// 4. Web app: Searches Form Responses (Clean) and marks event day check-in
//
// IMPORTANT: Re-run DataClean.gs whenever Form Responses 1 is updated with new approvals
// ============================================

// ═══════════════════════════════════════════════════════════════════════════
// 📋 TABLE OF CONTENTS - Quick Navigation Guide
// ═══════════════════════════════════════════════════════════════════════════
//
// CORE FUNCTIONS (Lines 48-410):
//   ├─ doGet() ............................ Line 48   | Web app entry point
//   ├─ checkInGuest() ..................... Line 80   | Guest check-in via ZIP/DOB/Gender
//   ├─ updateGuestScreenName() ............ Line 220  | Update guest screen name
//   └─ uploadGuestPhoto() ................. Line 295  | Upload photo to Drive ✅ FIXED
//
// HELPER FUNCTIONS (Lines 412-512):
//   ├─ safeString_() ...................... Line 416  | Safely convert to string
//   ├─ findHeaderIndex_() ................. Line 421  | Find column by header name
//   ├─ normalizeZip_() .................... Line 432  | Normalize ZIP code format
//   ├─ normalizeGender_() ................. Line 437  | Normalize gender value
//   ├─ parseMonthDay_() ................... Line 446  | Parse MM/DD format
//   ├─ monthDayFromCell_() ................ Line 463  | Extract month/day from cell
//   └─ getOrCreatePhotosFolder_() ......... Line 505  | Get or create Drive folder
//
// TEST & DEBUG FUNCTIONS (Lines 514-950):
//   ├─ testSheetStructure() ............... Line 518  | Verify column configuration
//   ├─ testCheckIn() ...................... Line 550  | Test check-in workflow
//   ├─ testEverything() ................... Line 578  | Run all tests
//   ├─ testSheetColumns() ................. Line 634  | Validate all columns
//   └─ testBackendFunctions() ............. Line 687  | Test all backend functions
//
// ANALYTICS FUNCTIONS (Lines 1680-2500):
//   ├─ getCompatibilityMatches() .......... Line ~1700 | Get guest matches for MM.html
//   ├─ getGuestSimilarities() ............. Line ~1800 | Calculate guest similarities
//   ├─ getPanAnalytics() .................. Line ~2000 | Pan data analytics
//   ├─ getVCramerAnalytics() .............. Line ~2200 | V-Cramer statistics
//   └─ getDemographicsSummary() ........... Line ~2300 | Demographics breakdown
//
// PHOTO MANAGEMENT (Lines 2662-2745):
//   ├─ convertDriveUrlToDirectLink() ...... Line 2665  | Convert URLs ✅ IMPROVED
//   ├─ syncPhotosFromDrive() .............. Line 2708  | Batch sync photo URLs
//   └─ manualSyncAllPhotos() .............. Line 2736  | Manual sync function
//
// RECENTLY MODIFIED:
//   ✅ Line 338-343: Photo upload now creates direct image links
//   ✅ Line 2665-2704: Improved URL conversion with better logging
//
// ═══════════════════════════════════════════════════════════════════════════

// ============================================
// GLOBAL CONSTANTS (DECLARED ONCE ONLY)
// ============================================



// ============================================
// WEB APP ENTRY POINT
// ============================================

/**
 * Main entry point for web app requests
 * 
 * DEPLOYMENT:
 * 1. Deploy → New deployment → Web app
 * 2. Execute as: Me
 * 3. Who has access: Anyone (or as needed)
 * 
 * URLs:
 * - https://script.google.com/.../exec → wall.html
 * - https://script.google.com/.../exec?page=wall → wall.html
 * 
 * @param {Object} e - Event object with query parameters
 * @return {HtmlOutput} Rendered HTML page
 */
/**
 * Main entry point - handles all page requests
 * 
function doGet(e) {
  const page = e.parameter.page || 'display';
  const fileId = e.parameter.fileId;
  
  // Image serving (for MM page photos)
  if (fileId) {
    try {
      const blob = DriveApp.getFileById(fileId).getBlob();
      return ContentService.createTextOutput()
        .setContent(blob.getBytes())
        .setMimeType(blob.getContentType());
    } catch (error) {
      Logger.log('Error serving image: ' + error);
      return HtmlService.createHtmlOutput('Image Error');
    }
  }
  
  // Page routing
  if (page === 'checkin') {
    return HtmlService.createHtmlOutputFromFile('CheckInInterface')
      .setTitle('Guest Check-In')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  if (page === 'display') {
    return HtmlService.createHtmlOutputFromFile('Display')
      .setTitle('Event Display')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }

  if (page === 'map') {
    return HtmlService.createHtmlOutputFromFile('MapDisplay')
      .setTitle('Map Display')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  if (page === 'wall') {
    return HtmlService.createHtmlOutputFromFile('wall')
      .setTitle('Network Wall')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  if (page === 'mm') {
    return HtmlService.createHtmlOutputFromFile('mm')
      .setTitle('Compatibility Matcher')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  // Individual pages
  const validPages = ['intro', 'msa', 'network'];
  if (validPages.includes(page)) {
    return HtmlService.createHtmlOutputFromFile(page)
      .setTitle(page)
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
  
  return HtmlService.createHtmlOutput('Page not found');
}

// ============================================
// MAIN CHECK-IN FUNCTION
// ============================================

function checkInGuest(payload) {
  // STEP 1: Extract and validate input
  const zip = safeString_(payload && payload.zip);
  const genderInput = safeString_(payload && payload.gender);
  const dobInput = safeString_(payload && payload.dob);

  if (!zip || !genderInput || !dobInput) {
    Logger.log('Check-in failed: Missing required fields');
    return { ok: false, message: 'Missing zip, gender, or DOB.' };
  }

  Logger.log('Check-in attempt: ZIP=' + zip + ', Gender=' + genderInput + ', DOB=' + dobInput);

  // STEP 2: Access the spreadsheet and sheet
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  
  if (!sh) {
    Logger.log('ERROR: Sheet not found: ' + SHEET_NAME);
    return { ok: false, message: 'Sheet "' + SHEET_NAME + '" not found.' };
  }

  // STEP 3: Get all data from sheet
  const data = sh.getDataRange().getValues();
  if (data.length < 2) {
    Logger.log('ERROR: Sheet is empty or has only headers');
    return { ok: false, message: 'No data to search.' };
  }

  Logger.log('Sheet has ' + (data.length - 1) + ' data rows');

  // STEP 4: Find gender and DOB columns dynamically
  const headers = data[0].map(safeString_);
  const genderCol = findHeaderIndex_(headers, ['self-identified gender', 'gender', 'sex']);
  const dobCol = findHeaderIndex_(headers, ['birthday (mm/dd)', 'birthday', 'dob', 'date of birth']);
  
  if (genderCol === -1 || dobCol === -1) {
    Logger.log('ERROR: Required columns not found. Gender col: ' + genderCol + ', DOB col: ' + dobCol);
    return { ok: false, message: 'Required columns not found in sheet.' };
  }

  Logger.log('Found columns - Gender: ' + genderCol + ', DOB: ' + dobCol);

  // STEP 5: Normalize search criteria
  const wantZip = normalizeZip_(zip);
  const wantGD = normalizeGender_(genderInput);
  const wantMD = parseMonthDay_(dobInput);
  
  if (!wantMD) {
    Logger.log('ERROR: Invalid DOB format: ' + dobInput);
    return { ok: false, message: 'DOB must be MM/DD format (e.g., 03/15).' };
  }

  Logger.log('Searching for: ZIP=' + wantZip + ', Gender=' + wantGD + ', DOB=' + wantMD.m + '/' + wantMD.d);

  // STEP 6: Search through all rows for exact match
  const matches = [];
  for (let r = 1; r < data.length; r++) {
    const row = data[r];
    
    const rowZip = normalizeZip_(safeString_(row[ZIP_COL - 1]));
    const rowGender = normalizeGender_(safeString_(row[genderCol]));
    const rowDOBRaw = row[dobCol];

    if (!rowZip || rowZip !== wantZip) continue;
    if (rowGender && wantGD && rowGender !== wantGD) continue;

    const md = monthDayFromCell_(rowDOBRaw);
    if (!md || md.m !== wantMD.m || md.d !== wantMD.d) continue;

    matches.push({ r, row });
    Logger.log('Match found at row ' + (r + 1));
  }

  // STEP 7: Validate match results
  if (matches.length === 0) {
    Logger.log('No matching guest found');
    return { ok: false, message: 'No matching guest found. Verify your information.' };
  }
  
  if (matches.length > 1) {
    Logger.log('ERROR: Multiple matches found (' + matches.length + ' guests)');
    return { ok: false, message: 'Multiple matches found. Contact event staff.' };
  }

  // STEP 8: Extract guest data from the single match
  const match = matches[0];
  const sheetRow = match.r + 1;
  const screenName = safeString_(match.row[SCREEN_NAME_COL - 1]);
  const uid = safeString_(match.row[UID_COL - 1]);
  const alreadyCheckedIn = safeString_(match.row[CHECKED_FLAG_COL - 1]).toUpperCase() === 'Y';

  // STEP 9: Check if already checked in
  if (alreadyCheckedIn) {
    Logger.log('Guest already checked in: ' + screenName);
    return {
      ok: true,
      alreadyCheckedIn: true,
      screenName: screenName || 'N/A',
      uid: uid || 'N/A',
      message: 'Welcome back, ' + screenName + '! You already checked in.'
    };
  }

  Logger.log('Check-in successful: ' + screenName + ' (' + uid + ') at row ' + sheetRow);

  // STEP 10: Mark guest as checked in with timestamp
  const lock = LockService.getScriptLock();
  try {
    lock.tryLock(10000);
    
    sh.getRange(sheetRow, CHECKED_FLAG_COL).setValue('Y');
    sh.getRange(sheetRow, CHECKED_TS_COL).setValue(new Date());
    
    SpreadsheetApp.flush();
    
    Logger.log('Sheet updated: Row ' + sheetRow + ' marked as checked in');
    
  } catch (error) {
    Logger.log('ERROR updating sheet: ' + error.toString());
    return { ok: false, message: 'Error during check-in: ' + error.toString() };
  } finally {
    lock.releaseLock();
  }

  // STEP 11: Return success with guest credentials
  return { 
    ok: true,
    alreadyCheckedIn: false,
    screenName: screenName || 'N/A',
    uid: uid || 'N/A',
    rowNumber: sheetRow,
    message: 'Check-in successful! Welcome, ' + screenName + '!'
  };
}

// ============================================
// SCREEN NAME UPDATE FUNCTION
// ============================================

function updateGuestScreenName(payload) {
  // STEP 1: Extract and validate input
  const uid = safeString_(payload && payload.uid);
  const newScreenName = safeString_(payload && payload.newScreenName);

  if (!uid || !newScreenName) {
    Logger.log('Update failed: Missing UID or screen name');
    return { ok: false, message: 'Missing UID or screen name.' };
  }

  Logger.log('Screen name update request: UID=' + uid + ', New name=' + newScreenName);

  // STEP 2: Validate screen name format
  if (newScreenName.length < 3) {
    Logger.log('Validation failed: Name too short');
    return { ok: false, message: 'Screen name must be at least 3 characters.' };
  }
  if (newScreenName.length > 50) {
    Logger.log('Validation failed: Name too long');
    return { ok: false, message: 'Screen name must be 50 characters or less.' };
  }

  // STEP 3: Access the spreadsheet
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) {
    Logger.log('ERROR: Sheet not found: ' + SHEET_NAME);
    return { ok: false, message: 'Sheet not found.' };
  }

  // STEP 4: Find guest by UID
  const data = sh.getDataRange().getValues();
  let targetRow = -1;
  
  for (let r = 1; r < data.length; r++) {
    if (safeString_(data[r][UID_COL - 1]) === uid) {
      targetRow = r + 1;
      Logger.log('Found guest at row ' + targetRow);
      break;
    }
  }

  if (targetRow === -1) {
    Logger.log('ERROR: Guest not found with UID: ' + uid);
    return { ok: false, message: 'Guest not found with UID: ' + uid };
  }

  // STEP 5: Update the screen name
  const lock = LockService.getScriptLock();
  try {
    lock.tryLock(10000);
    
    sh.getRange(targetRow, SCREEN_NAME_COL).setValue(newScreenName);
    SpreadsheetApp.flush();
    
    Logger.log('Screen name updated: ' + uid + ' → ' + newScreenName);
    
  } catch (error) {
    Logger.log('ERROR updating screen name: ' + error.toString());
    return { ok: false, message: 'Error updating: ' + error.toString() };
  } finally {
    lock.releaseLock();
  }

  return { 
    ok: true, 
    newScreenName: newScreenName,
    message: 'Screen name updated successfully!'
  };
}

// ============================================
// PHOTO UPLOAD FUNCTION
// ============================================

function uploadGuestPhoto(payload) {
  try {
    // STEP 1: Extract and validate input
    const uid = safeString_(payload && payload.uid);
    const fileName = safeString_(payload && payload.fileName);
    const mimeType = safeString_(payload && payload.mimeType);
    const base64Data = payload && payload.base64Data;

    if (!uid || !base64Data) {
      Logger.log('Upload failed: Missing UID or photo data');
      return { ok: false, message: 'Missing UID or photo data.' };
    }

    Logger.log('Photo upload started: UID=' + uid + ', File=' + fileName);

    // STEP 2: Decode base64 data to binary blob
    const blob = Utilities.newBlob(
      Utilities.base64Decode(base64Data),
      mimeType || 'image/jpeg',
      fileName || 'photo.jpg'
    );

    Logger.log('Photo decoded: ' + blob.getBytes().length + ' bytes');

    // STEP 3: Get or create photos folder in Google Drive
    const folder = getOrCreatePhotosFolder_();
    Logger.log('Using Drive folder: ' + folder.getName() + ' (ID: ' + folder.getId() + ')');

    // STEP 4: Create unique filename
    const timestamp = new Date().getTime();
    const cleanFileName = (fileName || 'photo.jpg').replace(/[^a-zA-Z0-9._-]/g, '_');
    const uniqueFileName = uid + '_' + timestamp + '_' + cleanFileName;
    
    Logger.log('Saving as: ' + uniqueFileName);

    // STEP 5: Upload file to Drive
    const file = folder.createFile(blob);
    file.setName(uniqueFileName);
    file.setDescription('Photo for guest UID: ' + uid + ' uploaded at ' + new Date().toString());

    // STEP 6: Set file permissions
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);

    // ✅ FIX: Get file ID and create thumbnail link (optimized for <img> tags)
    const fileId = file.getId();
    const fileUrl = 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w500';

    Logger.log('File uploaded: ' + fileUrl);
    Logger.log('File ID: ' + fileId);

    // STEP 7: Update spreadsheet with photo URL
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sh = ss.getSheetByName(SHEET_NAME);
    
    if (!sh) {
      Logger.log('WARNING: Sheet not found, but photo was uploaded');
      return { 
        ok: true, 
        fileUrl: fileUrl,
        fileId: fileId,
        message: 'Photo uploaded but could not update spreadsheet.' 
      };
    }

    // STEP 8: Find guest by UID
    const data = sh.getDataRange().getValues();
    let targetRow = -1;
    
    for (let r = 1; r < data.length; r++) {
      if (safeString_(data[r][UID_COL - 1]) === uid) {
        targetRow = r + 1;
        break;
      }
    }

    if (targetRow === -1) {
      Logger.log('WARNING: Guest not found, but photo was uploaded');
      return { 
        ok: true, 
        fileUrl: fileUrl,
        fileId: fileId,
        message: 'Photo uploaded but guest not found in spreadsheet.' 
      };
    }

    // STEP 9: Save photo URL to spreadsheet
    const lock = LockService.getScriptLock();
    try {
      lock.tryLock(10000);
      
      sh.getRange(targetRow, PHOTO_URL_COL).setValue(fileUrl);
      SpreadsheetApp.flush();
      
      Logger.log('Photo URL saved to row ' + targetRow);
      
    } finally {
      lock.releaseLock();
    }

    // STEP 10: Return success
    return { 
      ok: true, 
      fileUrl: fileUrl,
      fileId: fileId,
      message: 'Photo uploaded successfully!'
    };

  } catch (error) {
    Logger.log('ERROR uploading photo: ' + error.toString());
    Logger.log('Stack trace: ' + error.stack);
    return { 
      ok: false, 
      message: 'Error uploading photo: ' + error.toString() 
    };
  }
}

// ============================================
// SHARED HELPER FUNCTIONS
// ============================================

function safeString_(val) {
  if (val == null) return '';
  return String(val).trim();
}

function findHeaderIndex_(headers, possibilities) {
  for (let p of possibilities) {
    const norm = p.toLowerCase().replace(/[^a-z0-9]/g, '');
    for (let i = 0; i < headers.length; i++) {
      const h = headers[i].toLowerCase().replace(/[^a-z0-9]/g, '');
      if (h === norm) return i;
    }
  }
  return -1;
}

function normalizeZip_(zip) {
  const cleaned = zip.replace(/[^0-9]/g, '');
  return cleaned.length >= 5 ? cleaned.substring(0, 5) : cleaned;
}

function normalizeGender_(g) {
  const lower = g.toLowerCase();
  if (lower.includes('man') && !lower.includes('woman')) return 'man';
  if (lower.includes('woman')) return 'woman';
  if (lower.includes('non') || lower.includes('binary')) return 'nonbinary';
  if (lower.includes('other')) return 'other';
  return lower;
}

function parseMonthDay_(str) {
  const match = str.match(/^(\d{1,2})[\/\-](\d{1,2})$/);
  if (!match) return null;
  return { m: parseInt(match[1], 10), d: parseInt(match[2], 10) };
}

// ============================================
// ADD THIS TO YOUR Code.gs
// Place it in the "SHARED HELPER FUNCTIONS" section
// Replace the existing monthDayFromCell_ function
// ============================================

/**
 * monthDayFromCell_() - Extracts month and day from various cell formats
 * Handles Date objects and string formats like "10/07" or "10/07/1990"
 * UPDATED to better handle Date objects from Google Sheets
 */
function monthDayFromCell_(val) {
  if (!val) return null;
  
  // Handle Date objects (most common in Google Sheets)
  if (val instanceof Date) {
    // Get month and day from Date object
    const month = val.getMonth() + 1; // getMonth() returns 0-11
    const day = val.getDate();
    return { m: month, d: day };
  }
  
  // Handle string formats
  const str = String(val).trim();
  
  // If it looks like a full date string from Date.toString()
  if (str.includes('GMT') || str.includes('UTC')) {
    try {
      const dateObj = new Date(str);
      if (!isNaN(dateObj.getTime())) {
        return { m: dateObj.getMonth() + 1, d: dateObj.getDate() };
      }
    } catch (e) {
      // Fall through to pattern matching
    }
  }
  
  // Pattern matching for various string formats
  const patterns = [
    /^(\d{1,2})[\/\-](\d{1,2})(?:[\/\-]\d{2,4})?$/, // MM/DD or MM/DD/YYYY
    /^(\d{1,2})\/(\d{1,2})$/                         // MM/DD
  ];
  
  for (let pattern of patterns) {
    const match = str.match(pattern);
    if (match) {
      return { m: parseInt(match[1], 10), d: parseInt(match[2], 10) };
    }
  }
  
  return null;
}

function getOrCreatePhotosFolder_() {
  const folders = DriveApp.getFoldersByName(PHOTOS_FOLDER_NAME);
  if (folders.hasNext()) {
    return folders.next();
  }
  Logger.log('Creating new Drive folder: ' + PHOTOS_FOLDER_NAME);
  return DriveApp.createFolder(PHOTOS_FOLDER_NAME);
}

// ============================================
// TEST AND DEBUG FUNCTIONS
// ============================================

function testSheetStructure() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  
  if (!sh) {
    Logger.log('ERROR: Sheet not found: ' + SHEET_NAME);
    return;
  }
  
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  Logger.log('=== SHEET STRUCTURE ===');
  Logger.log('Sheet: ' + SHEET_NAME);
  Logger.log('Total columns: ' + headers.length);
  Logger.log('');
  Logger.log('Column mapping:');
  
  for (let i = 0; i < headers.length; i++) {
    const colNum = i + 1;
    const colLetter = String.fromCharCode(65 + (i % 26));
    Logger.log('  Column ' + colNum + ' (' + colLetter + '): ' + headers[i]);
  }
  
  Logger.log('');
  Logger.log('Current constants:');
  Logger.log('  ZIP_COL = ' + ZIP_COL + ' (' + headers[ZIP_COL - 1] + ')');
  Logger.log('  SCREEN_NAME_COL = ' + SCREEN_NAME_COL + ' (' + headers[SCREEN_NAME_COL - 1] + ')');
  Logger.log('  UID_COL = ' + UID_COL + ' (' + headers[UID_COL - 1] + ')');
  Logger.log('  CHECKED_FLAG_COL = ' + CHECKED_FLAG_COL + ' (' + headers[CHECKED_FLAG_COL - 1] + ')');
  Logger.log('  CHECKED_TS_COL = ' + CHECKED_TS_COL + ' (' + headers[CHECKED_TS_COL - 1] + ')');
  Logger.log('  PHOTO_URL_COL = ' + PHOTO_URL_COL + ' (' + headers[PHOTO_URL_COL - 1] + ')');
}

function testCheckIn() {
  Logger.log('=== TESTING CHECK-IN ===');
  
  const result = checkInGuest({
    zip: '64110',
    gender: 'man',
    dob: '10/07'
  });
  
  Logger.log('Result: ' + JSON.stringify(result, null, 2));
  
  if (result.ok) {
    Logger.log('✅ SUCCESS: Guest checked in');
  } else {
    Logger.log('❌ FAILED: ' + result.message);
  }
}

/**
 * COMPREHENSIVE TEST SUITE
 * Copy this into your Code.gs file at the bottom
 * Run testEverything() to validate your entire setup
 */

/**
 * Master test function - runs all tests
 * Run this to validate your entire system
 */
function testEverything() {
  Logger.log('========================================');
  Logger.log('🧪 COMPREHENSIVE SYSTEM TEST');
  Logger.log('========================================\n');
  
  let allPassed = true;
  
  // Test 1: Sheet Structure
  Logger.log('TEST 1: Sheet Structure');
  Logger.log('------------------------');
  if (!testSheetColumns()) {
    allPassed = false;
  }
  Logger.log('');
  
  // Test 2: Backend Functions
  Logger.log('TEST 2: Backend Functions');
  Logger.log('------------------------');
  if (!testBackendFunctions()) {
    allPassed = false;
  }
  Logger.log('');
  
  // Test 3: HTML/Code Alignment
  Logger.log('TEST 3: HTML/Code.gs Alignment');
  Logger.log('------------------------');
  if (!testHTMLAlignment()) {
    allPassed = false;
  }
  Logger.log('');
  
  // Test 4: Sample Check-In
  Logger.log('TEST 4: Sample Check-In (with real data)');
  Logger.log('------------------------');
  if (!testSampleCheckIn()) {
    allPassed = false;
  }
  Logger.log('');
  
  // Final Results
  Logger.log('========================================');
  if (allPassed) {
    Logger.log('✅ ALL TESTS PASSED!');
    Logger.log('Your system is ready to deploy!');
  } else {
    Logger.log('❌ SOME TESTS FAILED');
    Logger.log('Please fix the issues above before deploying.');
  }
  Logger.log('========================================');
  
  return allPassed;
}

/**
 * Test 1: Verify sheet has all required columns
 */
function testSheetColumns() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  
  if (!sh) {
    Logger.log('❌ FAIL: Sheet "' + SHEET_NAME + '" not found');
    Logger.log('   → Run DataClean.gs first!');
    return false;
  }
  
  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  const totalCols = headers.length;
  
  Logger.log('Sheet: ' + SHEET_NAME);
  Logger.log('Total columns: ' + totalCols);
  
  // Check required columns
  const required = [
    {col: ZIP_COL, name: 'Current 5 Digit Zip Code'},
    {col: SCREEN_NAME_COL, name: 'Screen Name'},
    {col: UID_COL, name: 'UID'},
    {col: CHECKED_FLAG_COL, name: 'Checked-In at Event'},
    {col: CHECKED_TS_COL, name: 'Check-In Timestamp'},
    {col: PHOTO_URL_COL, name: 'Photo URL'}
  ];
  
  let allFound = true;
  
  for (let req of required) {
    const actualName = headers[req.col - 1];
    
    if (!actualName) {
      Logger.log('❌ FAIL: Column ' + req.col + ' (' + req.name + ') is MISSING');
      allFound = false;
    } else if (actualName !== req.name) {
      Logger.log('⚠️  WARN: Column ' + req.col + ' is "' + actualName + '" (expected "' + req.name + '")');
    } else {
      Logger.log('✅ Column ' + req.col + ': ' + req.name);
    }
  }
  
  if (!allFound) {
    Logger.log('\n💡 FIX: Run cleanFormResponses() in DataClean.gs to create missing columns');
    return false;
  }
  
  Logger.log('✅ All required columns exist!');
  return true;
}

/**
 * Test 2: Verify backend functions exist and are callable
 */
function testBackendFunctions() {
  const requiredFunctions = [
    'checkInGuest',
    'updateGuestScreenName',
    'uploadGuestPhoto',
    'doGet'
  ];
  
  let allExist = true;
  
  for (let funcName of requiredFunctions) {
    if (typeof this[funcName] === 'function') {
      Logger.log('✅ ' + funcName + '() exists');
    } else {
      Logger.log('❌ FAIL: ' + funcName + '() NOT FOUND');
      allExist = false;
    }
  }
  
  if (!allExist) {
    Logger.log('\n💡 FIX: Make sure Code.gs has all required functions');
    return false;
  }
  
  // Test doGet returns HTML
  try {
    const output = doGet();
    if (output && output.getContent) {
      Logger.log('✅ doGet() returns valid HTML output');
    } else {
      Logger.log('❌ FAIL: doGet() does not return HTML');
      return false;
    }
  } catch (e) {
    Logger.log('❌ FAIL: doGet() threw error: ' + e.message);
    return false;
  }
  
  Logger.log('✅ All backend functions exist!');
  return true;
}

/**
 * Test 4: Test actual check-in with sample data
 * FIXED VERSION - properly converts Date objects to MM/DD format
 */
function testSampleCheckIn() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  
  if (!sh) {
    Logger.log('❌ FAIL: Cannot test - sheet not found');
    return false;
  }
  
  const data = sh.getDataRange().getValues();
  if (data.length < 2) {
    Logger.log('⚠️  SKIP: No guest data to test with');
    Logger.log('   Add some guests to "Form Responses (Clean)" first');
    return true; // Not a failure, just no data
  }
  
  // Get first guest's data
  const headers = data[0];
  const firstGuest = data[1];
  
  const zipCol = headers.indexOf('Current 5 Digit Zip Code');
  const genderCol = headers.indexOf('Self-Identified Gender');
  const dobCol = headers.indexOf('Birthday (MM/DD)');
  const screenNameCol = headers.indexOf('Screen Name');
  
  if (zipCol === -1 || genderCol === -1 || dobCol === -1) {
    Logger.log('❌ FAIL: Required columns not found in sheet');
    return false;
  }
  
  const testZip = String(firstGuest[zipCol] || '').trim();
  const testGender = String(firstGuest[genderCol] || '').trim().toLowerCase();
  const rawDOB = firstGuest[dobCol];
  const expectedName = String(firstGuest[screenNameCol] || '').trim();
  
  // CRITICAL FIX: Convert DOB to MM/DD format
  let formattedDOB;
  
  if (rawDOB instanceof Date) {
    // If it's a Date object, extract month and day
    const month = String(rawDOB.getMonth() + 1).padStart(2, '0');
    const day = String(rawDOB.getDate()).padStart(2, '0');
    formattedDOB = month + '/' + day;
    Logger.log('Converted Date object to MM/DD format');
  } else {
    // If it's a string, extract MM/DD only
    const dobStr = String(rawDOB).trim();
    const dobParts = dobStr.split('/');
    if (dobParts.length >= 2) {
      const month = dobParts[0].padStart(2, '0');
      const day = dobParts[1].padStart(2, '0');
      formattedDOB = month + '/' + day;
    } else {
      formattedDOB = dobStr;
    }
  }
  
  Logger.log('Testing with first guest in sheet:');
  Logger.log('  ZIP: ' + testZip);
  Logger.log('  Gender: ' + testGender);
  Logger.log('  DOB (raw): ' + rawDOB);
  Logger.log('  DOB (formatted): ' + formattedDOB);
  Logger.log('  Expected Name: ' + expectedName);
  
  if (!testZip || !testGender || !formattedDOB) {
    Logger.log('⚠️  SKIP: Guest data incomplete - cannot test');
    return true;
  }
  
  // Test check-in with properly formatted data
  try {
    const result = checkInGuest({
      zip: testZip,
      gender: testGender,
      dob: formattedDOB
    });
    
    Logger.log('\nCheck-in result:');
    Logger.log(JSON.stringify(result, null, 2));
    
    if (result.ok) {
      Logger.log('✅ Check-in successful!');
      Logger.log('   Screen Name: ' + result.screenName);
      Logger.log('   UID: ' + result.uid);
      
      if (result.screenName !== expectedName) {
        Logger.log('⚠️  Note: Screen name differs (may have been updated)');
      }
      
      return true;
    } else {
      Logger.log('❌ FAIL: Check-in failed');
      Logger.log('   Message: ' + result.message);
      return false;
    }
    
  } catch (e) {
    Logger.log('❌ FAIL: Check-in threw error');
    Logger.log('   Error: ' + e.message);
    Logger.log('   Stack: ' + e.stack);
    return false;
  }
}

/**
 * ALSO UPDATE testHTMLAlignment to be less strict
 */
function testHTMLAlignment() {
  let allAligned = true;
  
  // Test that HTML file exists
  try {
    const html = HtmlService.createHtmlOutputFromFile('CheckInInterface');
    const content = html.getContent();
    
    Logger.log('✅ CheckInInterface.html exists and is loadable');
    
    // Check if HTML contains required elements
    const requiredElements = [
      'checkInForm',
      'zip',
      'gender',
      'dob',
      'checkInBtn',
      'guestInfo',
      'photoInput'
    ];
    
    for (let elemId of requiredElements) {
      if (content.includes('id="' + elemId + '"')) {
        Logger.log('✅ HTML has element: ' + elemId);
      } else {
        Logger.log('❌ FAIL: HTML missing element: ' + elemId);
        allAligned = false;
      }
    }
    
    // Check if HTML calls correct backend functions (more flexible check)
    const requiredCalls = [
      {name: 'checkInGuest', pattern: /google\.script\.run[.\s\S]*checkInGuest/},
      {name: 'updateGuestScreenName', pattern: /google\.script\.run[.\s\S]*updateGuestScreenName/},
      {name: 'uploadGuestPhoto', pattern: /google\.script\.run[.\s\S]*uploadGuestPhoto/}
    ];
    
    for (let call of requiredCalls) {
      if (call.pattern.test(content)) {
        Logger.log('✅ HTML calls: ' + call.name);
      } else {
        Logger.log('⚠️  WARN: HTML might not call: ' + call.name);
        Logger.log('   (This is OK if the function name appears in HTML somewhere)');
        // Don't fail on this - just warn
        if (!content.includes(call.name)) {
          Logger.log('❌ FAIL: Function name "' + call.name + '" not found anywhere in HTML');
          allAligned = false;
        }
      }
    }
    
  } catch (e) {
    Logger.log('❌ FAIL: Cannot load CheckInInterface.html');
    Logger.log('   Error: ' + e.message);
    Logger.log('\n💡 FIX: Make sure CheckInInterface.html exists with proper HTML content');
    return false;
  }
  
  if (!allAligned) {
    Logger.log('\n💡 FIX: Replace CheckInInterface.html with the HTML artifact provided');
    return false;
  }
  
  Logger.log('✅ HTML and Code.gs are aligned!');
  return true;
}

/**
 * Quick test with your own data
 * UPDATE THESE VALUES and run this function
 */
function testCheckInWithMyData() {
  Logger.log('========================================');
  Logger.log('🧪 CUSTOM CHECK-IN TEST');
  Logger.log('========================================\n');
  
  // ⬇️⬇️⬇️ UPDATE THESE WITH REAL DATA FROM YOUR SHEET ⬇️⬇️⬇️
  const testData = {
    zip: '64110',      // ← Change this
    gender: 'man',     // ← Change this (man/woman/nonbinary/other)
    dob: '10/07'       // ← Change this (MM/DD format)
  };
  // ⬆️⬆️⬆️ UPDATE THESE WITH REAL DATA FROM YOUR SHEET ⬆️⬆️⬆️
  
  Logger.log('Testing check-in with:');
  Logger.log('  ZIP: ' + testData.zip);
  Logger.log('  Gender: ' + testData.gender);
  Logger.log('  DOB: ' + testData.dob);
  Logger.log('');
  
  try {
    const result = checkInGuest(testData);
    
    Logger.log('Result:');
    Logger.log(JSON.stringify(result, null, 2));
    Logger.log('');
    
    if (result.ok) {
      Logger.log('✅ SUCCESS!');
      Logger.log('   Screen Name: ' + result.screenName);
      Logger.log('   UID: ' + result.uid);
      Logger.log('   Already Checked In: ' + (result.alreadyCheckedIn ? 'Yes' : 'No'));
    } else {
      Logger.log('❌ FAILED');
      Logger.log('   Message: ' + result.message);
      Logger.log('');
      Logger.log('💡 TROUBLESHOOTING:');
      Logger.log('   1. Verify the guest exists in "Form Responses (Clean)"');
      Logger.log('   2. Check ZIP is exact match (5 digits, no spaces)');
      Logger.log('   3. Gender must be lowercase: man/woman/nonbinary/other');
      Logger.log('   4. DOB must be MM/DD format (e.g., 03/15 not 3/15)');
    }
    
  } catch (e) {
    Logger.log('❌ ERROR');
    Logger.log('   ' + e.message);
    Logger.log('   Stack: ' + e.stack);
  }
  
  Logger.log('========================================');
}

/**
 * Test screen name update function
 */
function testScreenNameUpdate() {
  Logger.log('========================================');
  Logger.log('🧪 SCREEN NAME UPDATE TEST');
  Logger.log('========================================\n');
  
  // ⬇️⬇️⬇️ UPDATE THESE ⬇️⬇️⬇️
  const testUID = 'BW-902';           // ← Change to a real UID from your sheet
  const newName = 'TestName123';       // ← Change to your desired test name
  // ⬆️⬆️⬆️ UPDATE THESE ⬆️⬆️⬆️
  
  Logger.log('Testing screen name update:');
  Logger.log('  UID: ' + testUID);
  Logger.log('  New Name: ' + newName);
  Logger.log('');
  
  try {
    const result = updateGuestScreenName({
      uid: testUID,
      newScreenName: newName
    });
    
    Logger.log('Result:');
    Logger.log(JSON.stringify(result, null, 2));
    Logger.log('');
    
    if (result.ok) {
      Logger.log('✅ SUCCESS! Name updated to: ' + result.newScreenName);
    } else {
      Logger.log('❌ FAILED: ' + result.message);
    }
    
  } catch (e) {
    Logger.log('❌ ERROR: ' + e.message);
  }
  
  Logger.log('========================================');
}

/**
 * Debug Check-In - Shows exactly what's being compared
 * Add this to Code.gs and run it to see why guests aren't matching
 */
function debugCheckIn() {
  Logger.log('========================================');
  Logger.log('🔍 CHECK-IN DEBUG MODE');
  Logger.log('========================================\n');
  
  // ⬇️⬇️⬇️ ENTER THE DATA YOU'RE TRYING TO CHECK IN WITH ⬇️⬇️⬇️
  const searchData = {
    zip: '64110',      // ← What you entered in the form
    gender: 'man',     // ← What you selected
    dob: '05/18'       // ← What you entered (MM/DD)
  };
  // ⬆️⬆️⬆️ CHANGE THESE TO MATCH WHAT YOU TRIED ⬆️⬆️⬆️
  
  Logger.log('🔎 SEARCHING FOR:');
  Logger.log('  ZIP: "' + searchData.zip + '"');
  Logger.log('  Gender: "' + searchData.gender + '"');
  Logger.log('  DOB: "' + searchData.dob + '"');
  Logger.log('');
  
  // Normalize search data (same way the check-in function does)
  const wantZip = normalizeZip_(searchData.zip);
  const wantGender = normalizeGender_(searchData.gender);
  const wantDOB = parseMonthDay_(searchData.dob);
  
  Logger.log('🔧 AFTER NORMALIZATION:');
  Logger.log('  ZIP: "' + wantZip + '"');
  Logger.log('  Gender: "' + wantGender + '"');
  Logger.log('  DOB: Month=' + wantDOB.m + ', Day=' + wantDOB.d);
  Logger.log('');
  Logger.log('========================================');
  Logger.log('📊 CHECKING SHEET DATA:');
  Logger.log('========================================\n');
  
  // Get sheet data
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  
  if (!sh) {
    Logger.log('❌ ERROR: Sheet not found!');
    return;
  }
  
  const data = sh.getDataRange().getValues();
  const headers = data[0].map(safeString_);
  
  // Find columns
  const genderCol = findHeaderIndex_(headers, ['self-identified gender', 'gender', 'sex']);
  const dobCol = findHeaderIndex_(headers, ['birthday (mm/dd)', 'birthday', 'dob', 'date of birth']);
  
  Logger.log('Column positions:');
  Logger.log('  ZIP: Column ' + ZIP_COL + ' (0-indexed: ' + (ZIP_COL - 1) + ')');
  Logger.log('  Gender: Column ' + (genderCol + 1) + ' (0-indexed: ' + genderCol + ')');
  Logger.log('  DOB: Column ' + (dobCol + 1) + ' (0-indexed: ' + dobCol + ')');
  Logger.log('');
  
  // Check first 5 rows
  Logger.log('First 5 guests in sheet:');
  Logger.log('----------------------------------------');
  
  for (let r = 1; r < Math.min(6, data.length); r++) {
    const row = data[r];
    
    const rowZipRaw = row[ZIP_COL - 1];
    const rowZip = normalizeZip_(safeString_(rowZipRaw));
    
    const rowGenderRaw = row[genderCol];
    const rowGender = normalizeGender_(safeString_(rowGenderRaw));
    
    const rowDOBRaw = row[dobCol];
    const rowDOB = monthDayFromCell_(rowDOBRaw);
    
    const rowScreenName = row[SCREEN_NAME_COL - 1];
    const rowUID = row[UID_COL - 1];
    
    Logger.log('Row ' + (r + 1) + ': ' + rowScreenName + ' (' + rowUID + ')');
    Logger.log('  ZIP (raw): "' + rowZipRaw + '"');
    Logger.log('  ZIP (normalized): "' + rowZip + '"');
    Logger.log('  Gender (raw): "' + rowGenderRaw + '"');
    Logger.log('  Gender (normalized): "' + rowGender + '"');
    Logger.log('  DOB (raw): ' + rowDOBRaw);
    Logger.log('  DOB (parsed): Month=' + (rowDOB ? rowDOB.m : 'null') + ', Day=' + (rowDOB ? rowDOB.d : 'null'));
    
    // Check if this row matches
    let zipMatch = rowZip === wantZip;
    let genderMatch = rowGender === wantGender;
    let dobMatch = rowDOB && rowDOB.m === wantDOB.m && rowDOB.d === wantDOB.d;
    
    Logger.log('  MATCH CHECK:');
    Logger.log('    ZIP Match: ' + (zipMatch ? '✅' : '❌') + ' (' + rowZip + ' vs ' + wantZip + ')');
    Logger.log('    Gender Match: ' + (genderMatch ? '✅' : '❌') + ' (' + rowGender + ' vs ' + wantGender + ')');
    Logger.log('    DOB Match: ' + (dobMatch ? '✅' : '❌') + ' (' + (rowDOB ? rowDOB.m + '/' + rowDOB.d : 'null') + ' vs ' + wantDOB.m + '/' + wantDOB.d + ')');
    
    if (zipMatch && genderMatch && dobMatch) {
      Logger.log('  🎉 FULL MATCH! This guest should check in successfully.');
    }
    
    Logger.log('');
  }
  
  Logger.log('========================================');
  Logger.log('💡 TROUBLESHOOTING TIPS:');
  Logger.log('========================================');
  Logger.log('1. ZIP Code: Must be exactly 5 digits');
  Logger.log('2. Gender: Must match exactly after normalization');
  Logger.log('   - Sheet has: "Man" → normalized to "man"');
  Logger.log('   - You enter: "man" → normalized to "man" ✅');
  Logger.log('3. Birthday: Must match month AND day');
  Logger.log('   - If DOB shows "null", the format is wrong in the sheet');
  Logger.log('   - Run DataClean.gs to fix birthday formats');
  Logger.log('4. If no rows match, try:');
  Logger.log('   - Use data from Row 2 exactly as shown above');
  Logger.log('   - Re-run DataClean.gs to refresh the sheet');
  Logger.log('========================================');
}

/**
 * Quick function to show ALL guests in your sheet
 * Use this to find a guest to test with
 */
function showAllGuests() {
  Logger.log('========================================');
  Logger.log('📋 ALL GUESTS IN SHEET');
  Logger.log('========================================\n');
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(SHEET_NAME);
  
  if (!sh) {
    Logger.log('❌ ERROR: Sheet not found!');
    return;
  }
  
  const data = sh.getDataRange().getValues();
  const headers = data[0];
  
  const genderCol = headers.indexOf('Self-Identified Gender');
  const dobCol = headers.indexOf('Birthday (MM/DD)');
  
  Logger.log('Total guests: ' + (data.length - 1));
  Logger.log('');
  
  for (let r = 1; r < data.length; r++) {
    const row = data[r];
    
    const zip = row[ZIP_COL - 1];
    const gender = row[genderCol];
    const dob = row[dobCol];
    const screenName = row[SCREEN_NAME_COL - 1];
    const uid = row[UID_COL - 1];
    
    // Convert DOB if it's a Date object
    let dobFormatted;
    if (dob instanceof Date) {
      const month = String(dob.getMonth() + 1).padStart(2, '0');
      const day = String(dob.getDate()).padStart(2, '0');
      dobFormatted = month + '/' + day;
    } else {
      dobFormatted = String(dob);
    }
    
    Logger.log('Row ' + (r + 1) + ': ' + screenName + ' (' + uid + ')');
    Logger.log('  Use this to check in:');
    Logger.log('    ZIP: ' + zip);
    Logger.log('    Gender: ' + String(gender).toLowerCase());
    Logger.log('    DOB: ' + dobFormatted);
    Logger.log('');
  }
  
  Logger.log('========================================');
  Logger.log('Copy the data from Row 2 above and use it in the web form!');
  Logger.log('========================================');
}


/**
 * Get all checked-in guests for wall display
 * Returns: [{uid, screenName, checkedAt}, ...]
 */
/**
 * Get all checked-in guests for wall display
 * Returns: [{uid, screenName, checkedAt, timestamp}, ...]
 */
/**
 * Get all checked-in guests for wall display
 * Returns: [{uid, screenName, checkedAt, timestamp}, ...]
 */
/**
 * Get all checked-in guests for wall display
 * Returns: [{uid, screenName, checkedAt, timestamp}, ...]
 * ✅ FIXED VERSION - Returns screenName
 */
function getWallData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Form Responses (Clean)');
  
  if (!sheet) {
    Logger.log('Sheet not found: Form Responses (Clean)');
    return [];
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // Find column indices
  const uidCol = headers.indexOf('UID');
  const screenNameCol = headers.indexOf('Screen Name');
  const checkedInCol = headers.indexOf('Checked-In at Event');
  const checkInTimeCol = headers.indexOf('Check-In Timestamp');
  
  if (uidCol === -1 || screenNameCol === -1) {
    Logger.log('ERROR: Required columns not found');
    Logger.log('  UID col index: ' + uidCol);
    Logger.log('  Screen Name col index: ' + screenNameCol);
    return [];
  }
  
  const guests = [];
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    // Only include checked-in guests
    if (row[checkedInCol] === 'Y') {
      guests.push({
        uid: row[uidCol],
        screenName: row[screenNameCol],  // ← THIS IS THE CRITICAL LINE
        checkedAt: row[checkInTimeCol] ? formatTime(row[checkInTimeCol]) : '',
        timestamp: row[checkInTimeCol]
      });
    }
  }
  
  Logger.log('Found ' + guests.length + ' checked-in guests');
  return guests;
}

function formatTime(date) {
  if (!date) return '';
  
  const d = new Date(date);
  const hours = d.getHours().toString().padStart(2, '0');
  const minutes = d.getMinutes().toString().padStart(2, '0');
  const seconds = d.getSeconds().toString().padStart(2, '0');
  
  return hours + ':' + minutes + ':' + seconds;
}
  

function getDDDViolations() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dddSheet = ss.getSheetByName('DDD (Checked-In Only)');
  
  if (!dddSheet) {
    return [];
  }
  
  const data = dddSheet.getDataRange().getValues();
  const headers = data[0];
  
  const uidCol = headers.indexOf('UID');
  const violations = [];
  
  // Get all DDD columns (they start with "DDD - ")
  for (let i = 0; i < headers.length; i++) {
    if (headers[i].toString().startsWith('DDD - ')) {
      const violationType = headers[i].replace('DDD - ', '');
      
      // Check each guest
      for (let row = 1; row < data.length; row++) {
        if (data[row][i] === 1) {
          violations.push({
            uid: data[row][uidCol],
            type: violationType
          });
        }
      }
    }
  }
  
  return violations;
}


/**
 * Analyze all categories and generate connection pairs
 * Returns: { analyses: [...], topCommonalities: [...] }
 */
function getDetailedWallConnections() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const masterSheet = ss.getSheetByName('Pan_Master');
  const cleanSheet = ss.getSheetByName('Form Responses (Clean)');
  
  if (!masterSheet || !cleanSheet) {
    return { analyses: [] };
  }
  
  const cleanData = cleanSheet.getDataRange().getValues();
  const cleanHeaders = cleanData[0];
  
  const analyses = [];
  
  // Define demographic categories to analyze (MUST MATCH HTML expectations)
  const categories = [
    { name: 'AGE_RANGE', column: 'Age Range' },
    { name: 'EDUCATION_LEVEL', column: 'Education Level' },
    { name: 'SELF_IDENTIFIED_ETHNICITY', column: 'Self Identified Ethnicity' },
    { name: 'EMPLOYMENT_INFORMATION_INDUSTRY', column: 'Employment Information (Industry)' },
    { name: 'EMPLOYMENT_INFORMATION_ROLE', column: 'Employment Information (Role)' }
  ];
  
  // Get checked-in UIDs
  const uidCol = cleanHeaders.indexOf('UID');
  const checkedInCol = cleanHeaders.indexOf('Checked-In at Event');
  
  // Process each category
  categories.forEach(category => {
    const colIndex = cleanHeaders.indexOf(category.column);
    if (colIndex === -1) {
      Logger.log('Column not found: ' + category.column);
      return;
    }
    
    // Group guests by trait value
    const groups = {};
    
    for (let i = 1; i < cleanData.length; i++) {
      const uid = cleanData[i][uidCol];
      if (cleanData[i][checkedInCol] !== 'Y') continue;
      
      const value = String(cleanData[i][colIndex] || '').trim();
      if (!value) continue;
      
      if (!groups[value]) groups[value] = [];
      groups[value].push(uid);
    }
    
    // Create connections for each group
    Object.keys(groups).forEach(traitValue => {
      const uids = groups[traitValue];
      const connections = [];
      
      // Create connections between all pairs in this group
      for (let i = 0; i < uids.length; i++) {
        for (let j = i + 1; j < uids.length; j++) {
          connections.push({
            uid1: uids[i],
            uid2: uids[j]
          });
        }
      }
      
      if (connections.length > 0) {
        analyses.push({
          analysisType: category.name,
          traitValue: traitValue,
          connections: connections
        });
      }
    });
  });
  
  Logger.log('Generated ' + analyses.length + ' demographic analyses');
  return { analyses: analyses };
}

/**
 * Get scrolling intro text for header ticker
 */
function getIntroText() {
  return 'NETWORK OPTIMIZATION SYSTEM ACTIVE // ANALYZING SOCIAL CONNECTIONS // ' +
         'DEMOGRAPHIC INTEGRATION PROTOCOL ENABLED // REAL-TIME PATTERN DETECTION // ' +
         'CURATED EXPERIENCE OPTIMIZATION IN PROGRESS';
}

/**
 * Get geographic distribution data for map view
 * Returns: { target: {...}, zips: [...], totalCount: n }
 */
function getAllZipData() {
  try {
    const ss = SpreadsheetApp.getActive();
    const sheet = ss.getSheetByName(WALL_CLEAN_SHEET);
    
    if (!sheet) {
      return { error: 'Clean sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { error: 'No data found' };
    }
    
    const headers = data[0];
    const colMap = {};
    headers.forEach((h, i) => colMap[String(h).trim()] = i);
    
    const zipCol = colMap['Current 5 Digit Zip Code'];
    const checkedInCol = colMap['Checked-In at Event'];
    
    if (zipCol === undefined) {
      return { error: 'Zip code column not found' };
    }
    
    // Count guests per zip (checked-in only)
    const zipCounts = {};
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      const checkedIn = String(row[checkedInCol] || '').trim().toUpperCase();
      if (checkedIn !== 'Y') continue;
      
      const zip = String(row[zipCol] || '').trim();
      if (zip && zip.length === 5 && /^\d{5}$/.test(zip)) {
        zipCounts[zip] = (zipCounts[zip] || 0) + 1;
      }
    }
    
    // Geocode target
    const targetGeo = geocodeAddress(WALL_TARGET_ADDRESS);
    
    // Geocode all guest zips
    const zipLocations = [];
    Object.keys(zipCounts).forEach(zip => {
      const geo = geocodeZip(zip);
      if (geo && geo.lat && geo.lng) {
        zipLocations.push({
          zip: zip,
          count: zipCounts[zip],
          lat: geo.lat,
          lng: geo.lng
        });
      }
    });
    
    return {
      target: {
        lat: targetGeo.lat,
        lng: targetGeo.lng,
        displayName: '5317 Charlotte',
        count: Object.values(zipCounts).reduce((a, b) => a + b, 0)
      },
      zips: zipLocations,
      totalCount: Object.keys(zipCounts).length
    };
    
  } catch (error) {
    Logger.log('Error in getAllZipData: ' + error.toString());
    return { error: error.toString() };
  }
}

/**
 * Geocode full address
 */
function geocodeAddress(address) {
  try {
    const response = Maps.newGeocoder().geocode(address);
    if (response.results && response.results.length > 0) {
      const location = response.results[0].geometry.location;
      return {
        lat: location.lat,
        lng: location.lng
      };
    }
  } catch (error) {
    Logger.log('Geocoding error for address ' + address + ': ' + error);
  }
  
  // Default to KC center
  return { lat: 39.0997, lng: -94.5786 };
}

/**
 * Geocode zip code
 */
function geocodeZip(zip) {
  try {
    const response = Maps.newGeocoder().geocode(zip + ', USA');
    if (response.results && response.results.length > 0) {
      const location = response.results[0].geometry.location;
      return {
        lat: location.lat,
        lng: location.lng
      };
    }
  } catch (error) {
    Logger.log('Geocoding error for zip ' + zip + ': ' + error);
  }
  
  return null;
}

// Test functions
function testWallData() {
  const guests = getWallData();
  Logger.log('Total guests: ' + guests.length);
  if (guests.length > 0) {
    Logger.log('Sample guest: ' + JSON.stringify(guests[0]));
  }
}

function testWallConnections() {
  const result = getDetailedWallConnections();
  if (result.error) {
    Logger.log('Error: ' + result.error);
  } else {
    Logger.log('Total analyses: ' + result.analyses.length);
    Logger.log('Top commonality: ' + JSON.stringify(result.topCommonalities[0]));
  }
}


// In your Google Apps Script (Code.gs)

function getDDDViolations() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dddSheet = ss.getSheetByName('DDD (Checked-In Only)');
  
  if (!dddSheet) {
    Logger.log('DDD sheet not found');
    return [];
  }
  
  const data = dddSheet.getDataRange().getValues();
  const headers = data[0];
  const violations = [];
  
  // Column indices based on Master_Desc
  const uidCol = 1; // Column 2: UID
  const violationColumns = {
    'Birthday Format': 2,
    'More Than 3 Interests': 3,
    'Unknown Guest': 4, // This is "Do Not Know Host"
    'No Song Request': 5,
    'Vague Song Request': 6,
    'Multiple Songs Listed': 7,
    'No Artist Listed': 8,
    'Barely Knows Host': 9,
    'Fresh Acquaintance': 10,
    'Host Ambiguity': 11,
    'Age/Birthday Mismatch': 12,
    'Education/Career Implausibility': 13,
    'Meme/Joke Response': 14,
    'Music/Artist Genre Mismatch': 15,
    'Minimum Effort Detected': 16,
    'Stranger Danger': 17,
    'Relationship Contradiction': 18,
    'Special Snowflake Syndrome': 19,
    'Suspiciously Generic': 20
  };
  
  // Skip header row
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const uid = row[uidCol];
    
    if (!uid) continue;
    
    // Check each violation column
    Object.keys(violationColumns).forEach(violationType => {
      const colIndex = violationColumns[violationType];
      const hasViolation = row[colIndex] === 1 || row[colIndex] === '1';
      
      if (hasViolation) {
        violations.push({
          uid: uid,
          type: violationType,
          description: getViolationDescription(violationType)
        });
      }
    });
  }
  
  Logger.log('Found ' + violations.length + ' violations');
  return violations;
}

function getViolationDescription(type) {
  const descriptions = {
    'Birthday Format': 'Invalid birthday format detected',
    'More Than 3 Interests': 'Listed more than 3 interests (max 3 allowed)',
    'Unknown Guest': 'Does not know the host(s)',
    'No Song Request': 'Did not provide song request',
    'Vague Song Request': 'Song request too vague or unclear',
    'Multiple Songs Listed': 'Listed multiple songs instead of one',
    'No Artist Listed': 'Did not provide favorite artist',
    'Barely Knows Host': 'Knows host less than 3 months',
    'Fresh Acquaintance': 'Very new acquaintance with host',
    'Host Ambiguity': 'Unclear about which host they know',
    'Age/Birthday Mismatch': 'Age range does not match birthday',
    'Education/Career Implausibility': 'Education level inconsistent with career role',
    'Meme/Joke Response': 'Provided meme or joke responses',
    'Music/Artist Genre Mismatch': 'Artist does not match stated music preference',
    'Minimum Effort Detected': 'Minimal effort in form responses',
    'Stranger Danger': 'Multiple red flags indicating unknown guest',
    'Relationship Contradiction': 'Contradictory information about host relationship',
    'Special Snowflake Syndrome': 'Overly unique or attention-seeking responses',
    'Suspiciously Generic': 'Responses are too generic or template-like'
  };
  
  return descriptions[type] || 'Violation detected';
}


function formatTime(timestamp) {
  if (!timestamp) return 'N/A';
  const date = new Date(timestamp);
  return Utilities.formatDate(date, Session.getScriptTimeZone(), 'HH:mm');
}

/**
 * ============================================================================
 * REPORTS.GS - ALL PARTY SURVEY ANALYSIS REPORTS
 * ============================================================================
 * * Contains all report generation functions for party survey analysis.
 * Each function creates a formatted output sheet with analysis results.
 * * AVAILABLE REPORTS:
 * 1. buildDemographicsSummary() - Age, gender, ethnicity, education breakdown
 * 2. buildMusicInterestsReport() - Music preferences and general interests
 * 3. buildHostRelationshipReport() - Guest relationships with party hosts
 * 4. buildAttendeeAnalysis() - Compare attendees vs no-shows
 * 5. buildGuestProfiles() - Individual guest profile cards
 * * USAGE:
 * Run any function from the script editor or create a custom menu
 */

// ============================================================================
// REPORT 1: DEMOGRAPHICS SUMMARY
// ============================================================================

/**
 * Generate comprehensive demographic overview
 * Shows distributions across age, gender, ethnicity, education, employment
 * Output: Demographics_Summary sheet
 */
function buildDemographicsSummary() {
  const ss = SpreadsheetApp.getActive();
  const cleanSheet = ss.getSheetByName(REPORTS_CLEAN_SHEET);
  
  if (!cleanSheet) {
    throw new Error(`Sheet "${REPORTS_CLEAN_SHEET}" not found.`);
  }

  const data = cleanSheet.getDataRange().getValues();
  if (data.length < 2) {
    writeSheet_('Demographics_Summary', [['No data available']]);
    return;
  }

  const header = data[0];
  const colIdx = getColumnMap_(header);

  // Calculate overview metrics
  const totalCount = data.length - 1;
  const checkedInCount = data.slice(1).filter(row => 
    String(row[colIdx['Checked-In at Event']] || '').trim().toUpperCase() === 'Y'
  ).length;

  // Build report sections
  const sections = [];

  // Title and overview
  sections.push(['PARTY SURVEY DEMOGRAPHICS SUMMARY']);
  sections.push(['']);
  sections.push(['Metric', 'Count', 'Percentage']);
  sections.push(['Total Responses', totalCount, '100.0%']);
  sections.push(['Checked-In Attendees', checkedInCount, ((checkedInCount / totalCount) * 100).toFixed(1) + '%']);
  sections.push(['No-Shows', totalCount - checkedInCount, (((totalCount - checkedInCount) / totalCount) * 100).toFixed(1) + '%']);
  sections.push(['']);

  // Add distribution sections
  const demographicFields = [
    ['Age Range', 'AGE RANGE DISTRIBUTION'],
    ['Self-Identified Gender', 'GENDER DISTRIBUTION'],
    ['Self Identified Ethnicity', 'ETHNICITY DISTRIBUTION'],
    ['Education Level', 'EDUCATION LEVEL DISTRIBUTION'],
    ['Self-Identified Sexual Orientation', 'SEXUAL ORIENTATION DISTRIBUTION'],
    ['Employment Information (Industry)', 'INDUSTRY DISTRIBUTION'],
    ['Employment Information (Role)', 'ROLE DISTRIBUTION']
  ];

  demographicFields.forEach(([colName, title]) => {
    sections.push(...buildDistribution_(data, colIdx, colName, title, 'Checked-In at Event'));
    sections.push(['']);
  });

  writeSheet_('Demographics_Summary', sections);
  formatDemographicsSheet_();
}

/**
 * Build distribution table for a demographic variable
 */
function buildDistribution_(data, colIdx, colName, title, checkedInCol) {
  const dataColIdx = colIdx[colName];
  const checkedInIdx = colIdx[checkedInCol];
  
  if (dataColIdx === undefined) {
    return [[title], ['Column not found']];
  }

  const totalCounts = {};
  const checkedInCounts = {};

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][dataColIdx] || '').trim();
    const isCheckedIn = String(data[i][checkedInIdx] || '').trim().toUpperCase() === 'Y';

    if (!value) continue;

    totalCounts[value] = (totalCounts[value] || 0) + 1;
    if (isCheckedIn) {
      checkedInCounts[value] = (checkedInCounts[value] || 0) + 1;
    }
  }

  const sortedValues = Object.keys(totalCounts).sort((a, b) => totalCounts[b] - totalCounts[a]);
  const totalSum = Object.values(totalCounts).reduce((a, b) => a + b, 0);
  const checkedInSum = Object.values(checkedInCounts).reduce((a, b) => a + b, 0);

  const rows = [
    [title],
    ['Category', 'Total', '% of Total', 'Checked-In', '% of Checked-In']
  ];

  sortedValues.forEach(value => {
    const totalCount = totalCounts[value];
    const checkedInCount = checkedInCounts[value] || 0;
    const totalPct = ((totalCount / totalSum) * 100).toFixed(1);
    const checkedInPct = checkedInSum > 0 ? ((checkedInCount / checkedInSum) * 100).toFixed(1) : '0.0';

    rows.push([value, totalCount, `${totalPct}%`, checkedInCount, `${checkedInPct}%`]);
  });

  rows.push(['TOTAL', totalSum, '100.0%', checkedInSum, '100.0%']);

  return rows;
}

function formatDemographicsSheet_() {
  const sheet = SpreadsheetApp.getActive().getSheetByName('Demographics_Summary');
  if (!sheet) return;

  const data = sheet.getDataRange().getValues();
  
  for (let row = 1; row <= data.length; row++) {
    const cellValue = String(data[row - 1][0] || '').trim();
    
    if (cellValue === 'PARTY SURVEY DEMOGRAPHICS SUMMARY') {
      sheet.getRange(row, 1, 1, 5).setFontWeight('bold').setFontSize(12)
        .setBackground('#1c4587').setFontColor('#ffffff');
    } else if (cellValue.toUpperCase() === cellValue && cellValue.includes('DISTRIBUTION')) {
      sheet.getRange(row, 1, 1, 5).setFontWeight('bold').setFontSize(11)
        .setBackground('#4a86e8').setFontColor('#ffffff');
    } else if (cellValue === 'Category' || cellValue === 'Metric') {
      sheet.getRange(row, 1, 1, 5).setFontWeight('bold').setBackground('#d9d9d9');
    } else if (cellValue === 'TOTAL') {
      sheet.getRange(row, 1, 1, 5).setFontWeight('bold').setBackground('#f3f3f3');
    }
  }

  for (let col = 1; col <= 5; col++) {
    sheet.autoResizeColumn(col);
  }
}

// ============================================================================
// REPORT 2: MUSIC & INTERESTS
// ============================================================================

/**
 * Analyze music preferences and general interests
 * Output: Music_Interests_Report sheet
 */
function buildMusicInterestsReport() {
  const ss = SpreadsheetApp.getActive();
  const cleanSheet = ss.getSheetByName(REPORTS_CLEAN_SHEET);
  
  if (!cleanSheet) {
    throw new Error(`Sheet "${REPORTS_CLEAN_SHEET}" not found.`);
  }

  const data = cleanSheet.getDataRange().getValues();
  if (data.length < 2) {
    writeSheet_('Music_Interests_Report', [['No data available']]);
    return;
  }

  const header = data[0];
  const colIdx = getColumnMap_(header);

  const sections = [];

  // Title
  sections.push(['MUSIC & INTERESTS ANALYSIS']);
  sections.push(['']);

  // Music Preferences
  sections.push(...buildMusicPreferences_(data, colIdx));
  sections.push(['']);

  // Top Artists
  sections.push(...buildTopArtists_(data, colIdx, 15));
  sections.push(['']);

  // Top Interests
  sections.push(...buildTopInterests_(data, colIdx));
  sections.push(['']);

  // Music by Age
  sections.push(...buildMusicByDemographic_(data, colIdx, 'Age Range', 'AGE GROUP'));
  sections.push(['']);

  // Music by Gender
  sections.push(...buildMusicByDemographic_(data, colIdx, 'Self-Identified Gender', 'GENDER'));
  sections.push(['']);

  // Song Requests
  sections.push(...buildSongRequestsSummary_(data, colIdx));

  writeSheet_('Music_Interests_Report', sections);
  formatGenericReport_('Music_Interests_Report');
}

function buildMusicPreferences_(data, colIdx) {
  const col = colIdx['Music Preference'];
  if (col === undefined) return [['MUSIC PREFERENCE DISTRIBUTION'], ['Column not found']];

  const counts = {};
  let total = 0;

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][col] || '').trim();
    if (!value) continue;
    counts[value] = (counts[value] || 0) + 1;
    total++;
  }

  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  const rows = [['MUSIC PREFERENCE DISTRIBUTION'], ['Genre', 'Count', 'Percentage']];

  sorted.forEach(([genre, count]) => {
    rows.push([genre, count, `${((count / total) * 100).toFixed(1)}%`]);
  });

  rows.push(['TOTAL', total, '100.0%']);
  return rows;
}

function buildTopArtists_(data, colIdx, limit) {
  const col = colIdx['Current Favorite Artist'];
  if (col === undefined) return [[`TOP ${limit} FAVORITE ARTISTS`], ['Column not found']];

  const counts = {};
  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][col] || '').trim();
    if (!value) continue;
    counts[value] = (counts[value] || 0) + 1;
  }

  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, limit);
  const rows = [[`TOP ${limit} FAVORITE ARTISTS`], ['Rank', 'Artist', 'Mentions']];

  sorted.forEach(([artist, count], idx) => {
    rows.push([idx + 1, artist, count]);
  });

  return rows;
}

function buildTopInterests_(data, colIdx) {
  const col = colIdx['Your General Interests (Choose 3)'];
  if (col === undefined) return [['TOP INTERESTS'], ['Column not found']];

  const counts = {};
  let totalResponses = 0;

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][col] || '').trim();
    if (!value) continue;
    totalResponses++;

    const interests = value.split(',').map(s => s.trim()).filter(s => s);
    interests.forEach(interest => {
      counts[interest] = (counts[interest] || 0) + 1;
    });
  }

  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  const rows = [['TOP INTERESTS'], ['Interest', 'Count', '% of Guests']];

  sorted.forEach(([interest, count]) => {
    rows.push([interest, count, `${((count / totalResponses) * 100).toFixed(1)}%`]);
  });

  return rows;
}

function buildMusicByDemographic_(data, colIdx, demoCol, demoLabel) {
  const musicCol = colIdx['Music Preference'];
  const demoColIdx = colIdx[demoCol];
  
  if (musicCol === undefined || demoColIdx === undefined) {
    return [[`MUSIC PREFERENCE BY ${demoLabel}`], ['Required columns not found']];
  }

  const crosstab = {};
  for (let i = 1; i < data.length; i++) {
    const demo = String(data[i][demoColIdx] || '').trim();
    const music = String(data[i][musicCol] || '').trim();
    if (!demo || !music) continue;

    if (!crosstab[demo]) crosstab[demo] = {};
    crosstab[demo][music] = (crosstab[demo][music] || 0) + 1;
  }

  const allGenres = new Set();
  Object.values(crosstab).forEach(musicCounts => {
    Object.keys(musicCounts).forEach(genre => allGenres.add(genre));
  });
  const genres = Array.from(allGenres).sort();
  const demos = Object.keys(crosstab).sort();

  const rows = [[`MUSIC PREFERENCE BY ${demoLabel}`], [demoCol, ...genres, 'Total']];

  demos.forEach(demo => {
    const row = [demo];
    let rowTotal = 0;
    genres.forEach(genre => {
      const count = crosstab[demo][genre] || 0;
      row.push(count);
      rowTotal += count;
    });
    row.push(rowTotal);
    rows.push(row);
  });

  return rows;
}

function buildSongRequestsSummary_(data, colIdx) {
  const col = colIdx['Name one song you want to hear at the party.'];
  if (col === undefined) return [['SONG REQUESTS SUMMARY'], ['Column not found']];

  let totalResponses = 0, withSong = 0, withoutSong = 0;

  for (let i = 1; i < data.length; i++) {
    totalResponses++;
    const value = String(data[i][col] || '').trim();
    if (value) withSong++; else withoutSong++;
  }

  const withPct = ((withSong / totalResponses) * 100).toFixed(1);
  const withoutPct = ((withoutSong / totalResponses) * 100).toFixed(1);

  return [
    ['SONG REQUESTS SUMMARY'],
    ['Category', 'Count', 'Percentage'],
    ['Provided Song Request', withSong, `${withPct}%`],
    ['No Song Request', withoutSong, `${withoutPct}%`],
    ['Total Responses', totalResponses, '100.0%']
  ];
}

// ============================================================================
// REPORT 3: HOST RELATIONSHIPS
// ============================================================================

/**
 * Analyze guest relationships with party hosts
 * Output: Host_Relationships sheet
 */
function buildHostRelationshipReport() {
  const ss = SpreadsheetApp.getActive();
  const cleanSheet = ss.getSheetByName(REPORTS_CLEAN_SHEET);
  
  if (!cleanSheet) {
    throw new Error(`Sheet "${REPORTS_CLEAN_SHEET}" not found.`);
  }

  const data = cleanSheet.getDataRange().getValues();
  if (data.length < 2) {
    writeSheet_('Host_Relationships', [['No data available']]);
    return;
  }

  const header = data[0];
  const colIdx = getColumnMap_(header);

  const sections = [];

  sections.push(['HOST RELATIONSHIP ANALYSIS']);
  sections.push(['']);

  // Overview
  sections.push(...buildHostOverview_(data, colIdx));
  sections.push(['']);

  // Duration Distribution
  sections.push(...buildHostDuration_(data, colIdx));
  sections.push(['']);

  // Which Host Known
  sections.push(...buildWhichHost_(data, colIdx));
  sections.push(['']);

  // Closeness Scores
  sections.push(...buildClosenessScores_(data, colIdx));
  sections.push(['']);

  // Closeness by Host
  sections.push(...buildClosenessbyHost_(data, colIdx));

  writeSheet_('Host_Relationships', sections);
  formatGenericReport_('Host_Relationships');
}

function buildHostOverview_(data, colIdx) {
  const col = colIdx['Do you know the Host(s)?'];
  if (col === undefined) return [['OVERVIEW'], ['Column not found']];

  let total = data.length - 1, knowHosts = 0, unknownGuests = 0;

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][col] || '').trim().toLowerCase();
    if (value.includes('yes') || value.includes('—')) knowHosts++;
    else if (value.includes('no')) unknownGuests++;
  }

  return [
    ['OVERVIEW'],
    ['Metric', 'Count', 'Percentage'],
    ['Total Guests', total, '100.0%'],
    ['Know Host(s)', knowHosts, `${((knowHosts / total) * 100).toFixed(1)}%`],
    ['Unknown Guests', unknownGuests, `${((unknownGuests / total) * 100).toFixed(1)}%`]
  ];
}

function buildHostDuration_(data, colIdx) {
  const col = colIdx['Do you know the Host(s)?'];
  if (col === undefined) return [['FRIENDSHIP DURATION'], ['Column not found']];

  const counts = {};
  let total = 0;

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][col] || '').trim();
    if (!value) continue;
    counts[value] = (counts[value] || 0) + 1;
    total++;
  }

  const order = ['No', 'Yes — 3–12 months', 'Yes — 1–3 years', 'Yes — 3–5 years', 'Yes — 5–10 years', 'Yes — more than 10 years'];
  const sorted = Object.keys(counts).sort((a, b) => {
    const idxA = order.indexOf(a);
    const idxB = order.indexOf(b);
    if (idxA === -1 && idxB === -1) return a.localeCompare(b);
    if (idxA === -1) return 1;
    if (idxB === -1) return -1;
    return idxA - idxB;
  });

  const rows = [['FRIENDSHIP DURATION DISTRIBUTION'], ['Duration', 'Count', 'Percentage']];

  sorted.forEach(duration => {
    const count = counts[duration];
    rows.push([duration, count, `${((count / total) * 100).toFixed(1)}%`]);
  });

  rows.push(['TOTAL', total, '100.0%']);
  return rows;
}

function buildWhichHost_(data, colIdx) {
  const col = colIdx['Which host have you known the longest?'];
  if (col === undefined) return [['WHICH HOST KNOWN LONGEST'], ['Column not found']];

  const counts = {};
  let total = 0;

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][col] || '').trim();
    if (!value) continue;
    counts[value] = (counts[value] || 0) + 1;
    total++;
  }

  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
  const rows = [['WHICH HOST KNOWN LONGEST'], ['Host', 'Count', 'Percentage']];

  sorted.forEach(([host, count]) => {
    rows.push([host, count, `${((count / total) * 100).toFixed(1)}%`]);
  });

  rows.push(['TOTAL', total, '100.0%']);
  return rows;
}

function buildClosenessScores_(data, colIdx) {
  const col = colIdx['If yes, how well do you know them?'];
  if (col === undefined) return [['CLOSENESS SCORE DISTRIBUTION'], ['Column not found']];

  const counts = {};
  let total = 0, sum = 0;

  for (let i = 1; i < data.length; i++) {
    const value = data[i][col];
    if (value === null || value === undefined || value === '') continue;
    const score = Number(value);
    if (!isFinite(score)) continue;
    
    counts[score] = (counts[score] || 0) + 1;
    sum += score;
    total++;
  }

  const avg = total > 0 ? (sum / total).toFixed(2) : 'N/A';
  const sorted = Object.keys(counts).sort((a, b) => Number(b) - Number(a));

  const rows = [
    ['CLOSENESS SCORE DISTRIBUTION (1=Acquaintance, 5=Close Friend)'],
    ['Score', 'Count', 'Percentage']
  ];

  sorted.forEach(score => {
    const count = counts[score];
    rows.push([score, count, `${((count / total) * 100).toFixed(1)}%`]);
  });

  rows.push(['TOTAL', total, '100.0%']);
  rows.push(['AVERAGE SCORE', avg, '']);
  return rows;
}

function buildClosenessbyHost_(data, colIdx) {
  const hostCol = colIdx['Which host have you known the longest?'];
  const scoreCol = colIdx['If yes, how well do you know them?'];
  
  if (hostCol === undefined || scoreCol === undefined) {
    return [['AVERAGE CLOSENESS BY HOST'], ['Required columns not found']];
  }

  const hostScores = {};

  for (let i = 1; i < data.length; i++) {
    const host = String(data[i][hostCol] || '').trim();
    const score = data[i][scoreCol];
    
    if (!host || score === null || score === undefined || score === '') continue;
    const scoreNum = Number(score);
    if (!isFinite(scoreNum)) continue;

    if (!hostScores[host]) hostScores[host] = { sum: 0, count: 0 };
    hostScores[host].sum += scoreNum;
    hostScores[host].count++;
  }

  const rows = [['AVERAGE CLOSENESS BY HOST'], ['Host', 'Count', 'Average Score']];

  Object.entries(hostScores).forEach(([host, data]) => {
    const avg = (data.sum / data.count).toFixed(2);
    rows.push([host, data.count, avg]);
  });

  return rows;
}

// ============================================================================
// REPORT 4: ATTENDEE VS NO-SHOW ANALYSIS
// ============================================================================

/**
 * Compare guests who attended vs those who didn't
 * Output: Attendee_Analysis sheet
 */
function buildAttendeeAnalysis() {
  const ss = SpreadsheetApp.getActive();
  const cleanSheet = ss.getSheetByName(REPORTS_CLEAN_SHEET);
  
  if (!cleanSheet) {
    throw new Error(`Sheet "${REPORTS_CLEAN_SHEET}" not found.`);
  }

  const data = cleanSheet.getDataRange().getValues();
  if (data.length < 2) {
    writeSheet_('Attendee_Analysis', [['No data available']]);
    return;
  }

  const header = data[0];
  const colIdx = getColumnMap_(header);

  const sections = [];

  sections.push(['ATTENDEE VS NO-SHOW ANALYSIS']);
  sections.push(['']);

  // Compare demographics
  const compareFields = [
    ['Age Range', 'AGE RANGE'],
    ['Self-Identified Gender', 'GENDER'],
    ['Education Level', 'EDUCATION'],
    ['Do you know the Host(s)?', 'HOST RELATIONSHIP']
  ];

  compareFields.forEach(([colName, label]) => {
    sections.push(...buildAttendeeComparison_(data, colIdx, colName, label));
    sections.push(['']);
  });

  writeSheet_('Attendee_Analysis', sections);
  formatGenericReport_('Attendee_Analysis');
}

function buildAttendeeComparison_(data, colIdx, colName, label) {
  const dataCol = colIdx[colName];
  const checkedInCol = colIdx['Checked-In at Event'];
  
  if (dataCol === undefined || checkedInCol === undefined) {
    return [[`${label} COMPARISON`], ['Required columns not found']];
  }

  const attendeeCounts = {};
  const noShowCounts = {};

  for (let i = 1; i < data.length; i++) {
    const value = String(data[i][dataCol] || '').trim();
    const isAttendee = String(data[i][checkedInCol] || '').trim().toUpperCase() === 'Y';

    if (!value) continue;

    if (isAttendee) {
      attendeeCounts[value] = (attendeeCounts[value] || 0) + 1;
    } else {
      noShowCounts[value] = (noShowCounts[value] || 0) + 1;
    }
  }

  const allValues = new Set([...Object.keys(attendeeCounts), ...Object.keys(noShowCounts)]);
  const sorted = Array.from(allValues).sort();

  const attendeeTotal = Object.values(attendeeCounts).reduce((a, b) => a + b, 0);
  const noShowTotal = Object.values(noShowCounts).reduce((a, b) => a + b, 0);

  const rows = [
    [`${label} COMPARISON: ATTENDEES VS NO-SHOWS`],
    ['Category', 'Attendees', '% Attendees', 'No-Shows', '% No-Shows']
  ];

  sorted.forEach(value => {
    const attendeeCount = attendeeCounts[value] || 0;
    const noShowCount = noShowCounts[value] || 0;
    const attendeePct = attendeeTotal > 0 ? ((attendeeCount / attendeeTotal) * 100).toFixed(1) : '0.0';
    const noShowPct = noShowTotal > 0 ? ((noShowCount / noShowTotal) * 100).toFixed(1) : '0.0';

    rows.push([value, attendeeCount, `${attendeePct}%`, noShowCount, `${noShowPct}%`]);
  });

  rows.push(['TOTAL', attendeeTotal, '100.0%', noShowTotal, '100.0%']);
  return rows;
}

// ============================================================================
// REPORT 5: GUEST PROFILE CARDS
// ============================================================================

/**
 * Create individual profile card for each guest
 * Output: Guest_Profiles sheet
 */
function buildGuestProfiles() {
  const ss = SpreadsheetApp.getActive();
  const cleanSheet = ss.getSheetByName(REPORTS_CLEAN_SHEET);
  // simSheet is not used in the function body, removed for clarity:
  // const simSheet = ss.getSheetByName('Guest_Similarity'); 
  
  if (!cleanSheet) {
    throw new Error(`Sheet "${REPORTS_CLEAN_SHEET}" not found.`);
  }

  const data = cleanSheet.getDataRange().getValues();
  if (data.length < 2) {
    writeSheet_('Guest_Profiles', [['No data available']]);
    return;
  }

  const header = data[0];
  const colIdx = getColumnMap_(header);

  // Build profiles
  const profiles = [
    ['Screen Name', 'UID', 'Age', 'Gender', 'Orientation', 'Ethnicity', 'Education', 'Industry', 'Role', 
     'Top 3 Interests', 'Music Genre', 'Favorite Artist', 'Personality Trait', 'Host Known Longest', 
     'Closeness', 'Checked-In']
  ];

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    
    // Parse interests
    const interestsStr = String(row[colIdx['Your General Interests (Choose 3)']] || '').trim();
    const interests = interestsStr.split(',').slice(0, 3).map(s => s.trim()).join(', ');

    profiles.push([
      row[colIdx['Screen Name']] || '',
      row[colIdx['UID']] || '',
      row[colIdx['Age Range']] || '',
      row[colIdx['Self-Identified Gender']] || '',
      row[colIdx['Self-Identified Sexual Orientation']] || '',
      row[colIdx['Self Identified Ethnicity']] || '',
      row[colIdx['Education Level']] || '',
      row[colIdx['Employment Information (Industry)']] || '',
      row[colIdx['Employment Information (Role)']] || '',
      interests,
      row[colIdx['Music Preference']] || '',
      row[colIdx['Current Favorite Artist']] || '',
      row[colIdx['At your worst you are…']] || '',
      row[colIdx['Which host have you known the longest?']] || '',
      row[colIdx['If yes, how well do you know them?']] || '',
      row[colIdx['Checked-In at Event']] || ''
    ]);
  }

  writeSheet_('Guest_Profiles', profiles);
  
  const sheet = ss.getSheetByName('Guest_Profiles');
  if (sheet) {
    sheet.getRange(1, 1, 1, profiles[0].length)
      .setFontWeight('bold')
      .setBackground('#4a86e8')
      .setFontColor('#ffffff');
    sheet.setFrozenRows(1);
    for (let col = 1; col <= profiles[0].length; col++) {
      sheet.autoResizeColumn(col);
    }
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Create column name to index mapping
 */
function getColumnMap_(header) {
  const map = {};
  header.forEach((col, idx) => {
    const colName = String(col || '').trim();
    if (colName) map[colName] = idx;
  });
  return map;
}

/**
 * Write data to a sheet
 */
function writeSheet_(sheetName, data) {
  const ss = SpreadsheetApp.getActive();
  let sheet = ss.getSheetByName(sheetName);
  
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
  }
  
  sheet.clear();

  if (!data || data.length === 0) {
    sheet.getRange(1, 1).setValue('No data to display');
    return;
  }

  // Find max columns
  const maxCols = Math.max(...data.map(row => Array.isArray(row) ? row.length : 1));

  // Pad rows to same length
  const paddedRows = data.map(row => {
    if (!Array.isArray(row)) return [row];
    const padded = [...row];
    while (padded.length < maxCols) padded.push('');
    return padded;
  });

  sheet.getRange(1, 1, paddedRows.length, maxCols).setValues(paddedRows);
}

/**
 * Apply generic formatting to report sheets
 */
function formatGenericReport_(sheetName) {
  const sheet = SpreadsheetApp.getActive().getSheetByName(sheetName);
  if (!sheet) return;

  const data = sheet.getDataRange().getValues();
  // Ensure data has at least one row to safely access data[0].
  if (data.length === 0) return;
  const maxCols = data[0].length;

  for (let col = 1; col <= maxCols; col++) {
    sheet.autoResizeColumn(col);
  }

  for (let row = 1; row <= data.length; row++) {
    const cellValue = String(data[row - 1][0] || '').trim();
    
    // Main titles (ends with ANALYSIS)
    if (cellValue.includes('ANALYSIS')) {
      sheet.getRange(row, 1, 1, maxCols)
        .setFontWeight('bold')
        .setFontSize(14)
        .setBackground('#1c4587')
        .setFontColor('#ffffff');
    }
    // Section headers (all caps with keywords)
    else if (cellValue.toUpperCase() === cellValue && cellValue.length > 0 &&
             (cellValue.includes('DISTRIBUTION') || cellValue.includes('TOP ') || 
              cellValue.includes('BY ') || cellValue.includes('SUMMARY') ||
              cellValue.includes('COMPARISON') || cellValue.includes('OVERVIEW'))) {
      sheet.getRange(row, 1, 1, maxCols)
        .setFontWeight('bold')
        .setFontSize(11)
        .setBackground('#4a86e8')
        .setFontColor('#ffffff');
    }
    // Column headers
    else if (['Category', 'Metric', 'Genre', 'Rank', 'Interest', 'Host', 'Duration', 
              'Score', 'Age Range', 'Gender'].includes(cellValue)) {
      sheet.getRange(row, 1, 1, maxCols)
        .setFontWeight('bold')
        .setBackground('#d9d9d9');
    }
    // Total rows
    else if (cellValue === 'TOTAL' || cellValue.includes('AVERAGE')) {
      sheet.getRange(row, 1, 1, maxCols)
        .setFontWeight('bold')
        .setBackground('#f3f3f3');
    }
  }
}

// ============================================================================
// QUICK TEST FUNCTIONS
// ============================================================================
// Add these to the BOTTOM of your Code.gs file
// Run after creating Config.gs

/**
 * Quick test to verify Config.gs constants are loading
 * RUN THIS FIRST after creating Config.gs
 */
function testConstants() {
  Logger.log('════════════════════════════════════════════════════════════════');
  Logger.log('🧪 TESTING CONSTANTS FROM CONFIG.GS');
  Logger.log('════════════════════════════════════════════════════════════════\n');
  
  try {
    Logger.log('✅ CORE SHEET NAMES:');
    Logger.log('   SHEET_NAME: ' + SHEET_NAME);
    Logger.log('   WALL_CLEAN_SHEET: ' + WALL_CLEAN_SHEET);
    Logger.log('   DDD_SHEET_NAME: ' + DDD_SHEET_NAME);
    Logger.log('');
    
    Logger.log('✅ FORM RESPONSES (CLEAN) COLUMNS:');
    Logger.log('   UID_COL: ' + UID_COL + ' (Column W)');
    Logger.log('   SCREEN_NAME_COL: ' + SCREEN_NAME_COL + ' (Column V)');
    Logger.log('   ZIP_COL: ' + ZIP_COL + ' (Column F)');
    Logger.log('   GENDER_COL: ' + GENDER_COL + ' (Column H)');
    Logger.log('   BIRTHDAY_COL: ' + BIRTHDAY_COL + ' (Column B)');
    Logger.log('   CHECKED_FLAG_COL: ' + CHECKED_FLAG_COL + ' (Column X)');
    Logger.log('   CHECKED_TS_COL: ' + CHECKED_TS_COL + ' (Column Y)');
    Logger.log('   PHOTO_URL_COL: ' + PHOTO_URL_COL + ' (Column Z)');
    Logger.log('');
    
    Logger.log('✅ DDD SHEET COLUMNS:');
    Logger.log('   DDD_UID_COL: ' + DDD_UID_COL + ' (Column B)');
    Logger.log('   DDD_SCREEN_NAME_COL: ' + DDD_SCREEN_NAME_COL + ' (Column A)');
    Logger.log('   DDD_UNKNOWN_GUEST_COL: ' + DDD_UNKNOWN_GUEST_COL + ' (Column E)');
    Logger.log('');
    
    Logger.log('✅ ANALYSIS CATEGORIES:');
    Logger.log('   Total categories: ' + ANALYSIS_CATEGORIES.length);
    Logger.log('   First 3:');
    ANALYSIS_CATEGORIES.slice(0, 3).forEach(cat => {
      Logger.log('   • ' + cat.name + ' → "' + cat.header + '"');
    });
    Logger.log('');
    
    Logger.log('════════════════════════════════════════════════════════════════');
    Logger.log('✅✅✅ ALL CONSTANTS LOADED SUCCESSFULLY! ✅✅✅');
    Logger.log('════════════════════════════════════════════════════════════════');
    Logger.log('✅ No duplicate declaration errors!');
    Logger.log('✅ Config.gs is working correctly!');
    Logger.log('✅ Ready to run completeSystemCheck()');
    Logger.log('════════════════════════════════════════════════════════════════\n');
    
    return true;
    
  } catch (e) {
    Logger.log('════════════════════════════════════════════════════════════════');
    Logger.log('❌❌❌ ERROR LOADING CONSTANTS ❌❌❌');
    Logger.log('════════════════════════════════════════════════════════════════');
    Logger.log('Error message: ' + e.message);
    Logger.log('Error line: ' + e.lineNumber);
    Logger.log('');
    Logger.log('TROUBLESHOOTING STEPS:');
    Logger.log('1. ✓ Make sure Config.gs file exists in file list');
    Logger.log('2. ✓ Make sure Config.gs is saved (💾 icon)');
    Logger.log('3. ✓ Remove ALL "const" lines from Code.gs');
    Logger.log('4. ✓ Remove ALL "const" lines from Utilities.gs');
    Logger.log('5. ✓ Close and reopen Apps Script editor');
    Logger.log('6. ✓ Try running testConstants() again');
    Logger.log('════════════════════════════════════════════════════════════════\n');
    
    return false;
  }
}

/**
 * Verify that duplicate constants have been removed
 * Run this to double-check your cleanup
 */
function verifyNoDuplicates() {
  Logger.log('════════════════════════════════════════════════════════════════');
  Logger.log('🔍 VERIFYING NO DUPLICATE CONSTANTS');
  Logger.log('════════════════════════════════════════════════════════════════\n');
  
  Logger.log('This test will pass if Config.gs is the ONLY place with constants.\n');
  
  Logger.log('MANUAL CHECK:');
  Logger.log('1. Open each .gs file in your project');
  Logger.log('2. Search (Ctrl+F) for: "const SHEET_NAME"');
  Logger.log('3. Should ONLY appear in Config.gs');
  Logger.log('4. If found elsewhere, delete that line');
  Logger.log('');
  Logger.log('FILES TO CHECK:');
  Logger.log('• Config.gs          → ✅ SHOULD have const declarations');
  Logger.log('• Code.gs            → ❌ SHOULD NOT have const declarations');
  Logger.log('• Utilities.gs       → ❌ SHOULD NOT have const declarations');
  Logger.log('• Reports.gs         → ❌ SHOULD NOT have const declarations');
  Logger.log('• DataClean.gs       → ❌ SHOULD NOT have const declarations');
  Logger.log('• Any other .gs file → ❌ SHOULD NOT have const declarations');
  Logger.log('');
  Logger.log('After cleanup, run testConstants() to verify!\n');
  Logger.log('════════════════════════════════════════════════════════════════\n');
}

/**
 * Show which constants you should remove from other files
 */
function showConstantsToRemove() {
  Logger.log('════════════════════════════════════════════════════════════════');
  Logger.log('🧹 CONSTANTS TO REMOVE FROM OTHER FILES');
  Logger.log('════════════════════════════════════════════════════════════════\n');
  
  Logger.log('SEARCH for these in Code.gs, Utilities.gs, and other files:');
  Logger.log('Then DELETE any lines you find (except in Config.gs)\n');
  
  const constantsToRemove = [
    'const SHEET_NAME',
    'const WALL_CLEAN_SHEET',
    'const REPORTS_CLEAN_SHEET',
    'const DDD_SHEET_NAME',
    'const PHOTOS_FOLDER_NAME',
    'const WALL_TARGET_ADDRESS',
    'const ZIP_COL',
    'const GENDER_COL',
    'const BIRTHDAY_COL',
    'const SCREEN_NAME_COL',
    'const UID_COL',
    'const CHECKED_FLAG_COL',
    'const CHECKED_TS_COL',
    'const PHOTO_URL_COL',
    'const DDD_UID_COL',
    'const ANALYSIS_CATEGORIES',
    'const CYCLE_INTERVAL',
    'const COLOR_PALETTE'
  ];
  
  Logger.log('DELETE THESE LINES from Code.gs and Utilities.gs:');
  Logger.log('─────────────────────────────────────────────────────────────');
  constantsToRemove.forEach((line, i) => {
    Logger.log((i + 1) + '. ' + line + ' = ...');
  });
  Logger.log('─────────────────────────────────────────────────────────────\n');
  
  Logger.log('HOW TO SEARCH:');
  Logger.log('1. Open Code.gs');
  Logger.log('2. Press Ctrl+F (or Cmd+F on Mac)');
  Logger.log('3. Type: const SHEET_NAME');
  Logger.log('4. If found, DELETE the entire line');
  Logger.log('5. Repeat for each constant above');
  Logger.log('6. Do the same for Utilities.gs and other files');
  Logger.log('7. Save all files');
  Logger.log('8. Run testConstants() to verify\n');
  
  Logger.log('════════════════════════════════════════════════════════════════\n');
}

function checkConfig() {
  try {
    Logger.log('Testing SHEET_NAME...');
    Logger.log(SHEET_NAME);
    Logger.log('✅ Config loaded!');
  } catch (e) {
    Logger.log('❌ Config NOT loaded: ' + e.message);
  }
}

/**
 * Convert Google Drive view link to direct image link
 * ✅ IMPROVED: Better pattern matching for multiple URL formats
 */
function convertDriveUrlToDirectLink(driveUrl) {
  if (!driveUrl || driveUrl === '') return '';

  try {
    let fileId = null;

    // Format 1: /file/d/FILEID/view or /file/d/FILEID
    let match = driveUrl.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
    if (match) {
      fileId = match[1];
    }

    // Format 2: ?id=FILEID or &id=FILEID
    if (!fileId) {
      match = driveUrl.match(/[?&]id=([a-zA-Z0-9_-]+)/);
      if (match) {
        fileId = match[1];
      }
    }

    // If we found a file ID, return thumbnail link (works better in <img> tags)
    if (fileId) {
      Logger.log('✅ Converting Drive URL: ' + driveUrl.substring(0, 50) + '... -> ID: ' + fileId);
      return 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w500';
    }

    // If already a thumbnail link, return as-is
    if (driveUrl.includes('drive.google.com/thumbnail')) {
      return driveUrl;
    }

    // If old format (/uc?export=view), convert to thumbnail
    if (driveUrl.includes('drive.google.com/uc?export=view')) {
      const match2 = driveUrl.match(/[?&]id=([a-zA-Z0-9_-]+)/);
      if (match2) {
        return 'https://drive.google.com/thumbnail?id=' + match2[1] + '&sz=w500';
      }
    }

    Logger.log('⚠️ Could not extract file ID from URL: ' + driveUrl.substring(0, 50));
    return driveUrl;

  } catch (error) {
    Logger.log('❌ Error converting Drive URL: ' + error.toString());
    return driveUrl;
  }
}

/**
 * Sync all photos from Drive view links to direct image links
 */
function syncPhotosFromDrive() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const cleanSheet = ss.getSheetByName('Form Responses (Clean)');
    
    if (!cleanSheet) {
      return { success: false, message: 'Form Responses (Clean) sheet not found' };
    }
    
    const data = cleanSheet.getDataRange().getValues();
    const photoUrlCol = 25; // Column Z (0-indexed = 25)
    
    let updatedCount = 0;
    
    for (let i = 1; i < data.length; i++) {
      const currentUrl = data[i][photoUrlCol];

      if (currentUrl && typeof currentUrl === 'string' && currentUrl.includes('drive.google.com')) {
        // Skip if already in thumbnail format
        if (currentUrl.includes('/thumbnail?id=')) {
          continue;
        }

        // Convert any other Drive URL format to thumbnail
        const thumbnailUrl = convertDriveUrlToDirectLink(currentUrl);

        if (thumbnailUrl !== currentUrl) {
          cleanSheet.getRange(i + 1, photoUrlCol + 1).setValue(thumbnailUrl);
          updatedCount++;
          Logger.log('Row ' + (i + 1) + ': ' + currentUrl.substring(0, 50) + '... -> thumbnail');
        }
      }
    }
    
    Logger.log(`✅ Photo sync complete: ${updatedCount} URLs converted`);
    
    return {
      success: true,
      updated: updatedCount,
      message: `Successfully converted ${updatedCount} photo URLs`
    };
    
  } catch (error) {
    Logger.log('❌ Error: ' + error.toString());
    return { success: false, message: error.toString() };
  }
}

/**
 * Manual function to sync all photos - RUN THIS!
 */
function manualSyncAllPhotos() {
  const result = syncPhotosFromDrive();
  
  SpreadsheetApp.getUi().alert(
    '📸 Photo URL Conversion Results\n\n' +
    (result.success ?
      `✅ Success!\n\nConverted ${result.updated} URLs to thumbnail format.\n\nThumbnail URLs work better in web apps!\n\nRefresh MM page to see photos.` :
      `❌ Failed\n\n${result.message}`)
  );
}

/**
 * Helper function to extract the Google Drive File ID from the raw 'Photo URL'.
 */
function extractFileId(url) {
  if (!url || typeof url !== 'string') return '';
  // The 'uc?export=view' format: extract the ID after 'id='
  const match = url.match(/id=([a-zA-Z0-9_-]+)/);
  return match ? match[1] : '';
}

/**
 * Helper function to extract the Google Drive File ID from the raw 'Photo URL'.
 */
function extractFileId(url) {
  if (!url || typeof url !== 'string') return '';
  // The 'uc?export=view' format: extract the ID after 'id='
  const match = url.match(/id=([a-zA-Z0-9_-]+)/);
  return match ? match[1] : '';
}

/**
 * [CRUCIAL STEP] This function acts as the secure image server.
 * It is triggered when the deployed Web App URL is accessed with the '?fileId=' parameter.
 * It fetches the file securely using DriveApp and returns the raw image content.
 */
function doGet(e) {
  const fileId = e.parameter.fileId;
  if (fileId) {
    try {
      // Get the file as a Blob
      const blob = DriveApp.getFileById(fileId).getBlob();
      
      // Serve the content. This is a robust way to bypass CORS issues.
      return ContentService.createTextOutput(blob.getBytes(), blob.getContentType());
      
    } catch (error) {
      Logger.log('❌ Error serving image for ID ' + fileId + ': ' + error.toString());
      // Return a 404/Error to the browser if the file is not found or access is denied
      return HtmlService.createHtmlOutput('Image Error').setMimeType(HtmlService.MimeType.TEXT);
    }
  }
  // This executes if the script is called without a fileId parameter (or as the main app entry)
  return HtmlService.createHtmlOutput('Invalid Request').setMimeType(HtmlService.MimeType.TEXT);
}

// Code.gs - Google Apps Script (SAME AS BEFORE)

function doGet() {
  return HtmlService.createHtmlOutputFromFile('MapDisplay')
    .setTitle('Zip Code Network - 5317 Charlotte')
    .setWidth(1400)
    .setHeight(900);
}

function getIntroText() {
  // EDIT THIS TEXT TO CHANGE THE ROLLING MESSAGE
  return "INPUT TEXT HERE";
}

function getZipCodesFromSheet() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('Form Responses 1');
    
    if (!sheet) {
      throw new Error('Sheet "Form Responses 1" not found');
    }
    
    const lastRow = sheet.getLastRow();
    
    if (lastRow < 2) {
      return {};
    }
    
    const zipRange = sheet.getRange(2, 5, lastRow - 1, 1);
    const zipValues = zipRange.getValues();
    
    // Count occurrences of each zip code
    const zipCounts = {};
    zipValues.forEach(row => {
      const zip = String(row[0]).trim();
      if (zip && zip !== '' && zip.length === 5) {
        zipCounts[zip] = (zipCounts[zip] || 0) + 1;
      }
    });
    
    return zipCounts;
    
  } catch (error) {
    Logger.log('Error: ' + error.toString());
    return {};
  }
}

function getAddressCoordinates(address) {
  try {
    const geocoder = Maps.newGeocoder();
    const location = geocoder.geocode(address);
    
    if (location.status === 'OK' && location.results.length > 0) {
      const result = location.results[0];
      return {
        lat: result.geometry.location.lat,
        lng: result.geometry.location.lng
      };
    }
    return null;
  } catch (error) {
    Logger.log('Error geocoding address: ' + error.toString());
    return null;
  }
}

function getZipCodeCoordinates(zipCode) {
  try {
    const geocoder = Maps.newGeocoder();
    const location = geocoder.geocode(zipCode + ', USA');
    
    if (location.status === 'OK' && location.results.length > 0) {
      const result = location.results[0];
      return {
        lat: result.geometry.location.lat,
        lng: result.geometry.location.lng,
        zip: zipCode
      };
    }
    return null;
  } catch (error) {
    Logger.log('Error geocoding ' + zipCode + ': ' + error.toString());
    return null;
  }
}

function getAllZipData() {
  const zipCounts = getZipCodesFromSheet();
  
  if (Object.keys(zipCounts).length === 0) {
    return { error: 'No zip codes found in Column E' };
  }
  
  const targetCount = zipCounts['64110'] || 0;
  
  // Geocode the specific address
  const targetCoords = getAddressCoordinates('5317 Charlotte St, Kansas City, MO 64110');
  if (!targetCoords) {
    return { error: 'Could not geocode target address' };
  }
  
  const target = {
    lat: targetCoords.lat,
    lng: targetCoords.lng,
    zip: '5317 Charlotte',
    count: targetCount,
    displayName: '5317 Charlotte'
  };
  
  const allZips = [];
  let totalRespondents = 0;
  
  Object.keys(zipCounts).forEach(zip => {
    totalRespondents += zipCounts[zip];
    
    if (zip !== '64110') {
      const coord = getZipCodeCoordinates(zip);
      if (coord) {
        coord.count = zipCounts[zip];
        allZips.push(coord);
      }
      Utilities.sleep(100);
    }
  });
  
  return {
    target: target,
    zips: allZips,
    totalCount: Object.keys(zipCounts).length,
    totalRespondents: totalRespondents
  };
}

function quickTest() {
  const guests = getWallData();
  Logger.log('First guest: ' + JSON.stringify(guests[0], null, 2));
  
  const connections = getDetailedWallConnections();
  Logger.log('First analysis type: ' + connections.analyses[0].analysisType);
}

function verifyScreenName() {
  Logger.log('=== VERIFYING SCREEN NAME ===');
  
  const guests = getWallData();
  
  Logger.log('Total guests: ' + guests.length);
  Logger.log('');
  Logger.log('First 3 guests:');
  
  for (let i = 0; i < Math.min(3, guests.length); i++) {
    Logger.log('Guest ' + (i + 1) + ':');
    Logger.log('  UID: ' + guests[i].uid);
    Logger.log('  Screen Name: ' + guests[i].screenName);
    Logger.log('  Checked At: ' + guests[i].checkedAt);
    Logger.log('  Has screenName property: ' + (guests[i].screenName !== undefined));
    Logger.log('');
  }
  
  Logger.log('Full JSON of first guest:');
  Logger.log(JSON.stringify(guests[0], null, 2));
}

